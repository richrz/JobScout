{
  "tdd": {
    "tasks": [
      {
        "id": "34",
        "title": "Backend Hardening & Mock Eradication",
        "description": "Purge mock logic from production paths and harden database connections.",
        "details": "Audit `job-scrapers.ts` and `resume-generator.ts`. Encapsulate all mock data generation behind a strict `NEXT_PUBLIC_MOCK_MODE` environment variable check. Refactor Prisma initialization to ensure connection resilience (retries, timeouts) and container awareness. Ensure production builds contain zero mock data artifacts.",
        "testStrategy": "Set `NEXT_PUBLIC_MOCK_MODE=false` and verify no mock data appears. Simulate DB connection drops to test reconnection logic.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Centralized Mock Mode Configuration",
            "description": "Define the environment variable and utility helper to control mock data generation application-wide.",
            "dependencies": [],
            "details": "Add `NEXT_PUBLIC_MOCK_MODE` to the environment schema validation (e.g., Zod or T3 Env). Create a type-safe utility function `isMockMode()` that returns a boolean. Update `.env.example` to include this variable with a default value of false.",
            "status": "done",
            "testStrategy": "Unit test the utility function with different process.env values to ensure it returns correct booleans.",
            "updatedAt": "2025-12-20T18:52:35.462Z",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Gate Job Scraper Mock Data",
            "description": "Refactor the job scraper service to strictly separate mock data from production logic using the new configuration.",
            "dependencies": [
              1
            ],
            "details": "Audit `job-scrapers.ts`. Locate all hardcoded mock job listings. Wrap the return statements in a conditional check `if (isMockMode())`. Ensure the 'else' path executes the real scraping logic or throws a specific error if the external service is unreachable.",
            "status": "in-progress",
            "testStrategy": "Run the scraper with MOCK_MODE=true and verify dummy data. Run with MOCK_MODE=false and verify real network requests are attempted.",
            "parentId": "undefined",
            "updatedAt": "2025-12-20T18:52:37.483Z"
          },
          {
            "id": 3,
            "title": "Gate Resume Generator Mock Data",
            "description": "Refactor the resume generator to ensure AI generation is only bypassed when mock mode is explicitly enabled.",
            "dependencies": [
              1
            ],
            "details": "Audit `resume-generator.ts`. Identify where dummy resume text/JSON is returned. Apply the environment variable check. Ensure that when mock mode is off, the code strictly calls the LLM provider API.",
            "status": "done",
            "testStrategy": "Trigger resume generation with MOCK_MODE=false and verify API credits are consumed or real errors occur.",
            "parentId": "undefined",
            "updatedAt": "2025-12-20T18:54:36.702Z"
          },
          {
            "id": 4,
            "title": "Enhance Prisma Client Resilience",
            "description": "Refactor the Prisma client instantiation to handle connection drops and container lifecycles robustly.",
            "dependencies": [],
            "details": "Modify the Prisma client singleton export. Add configuration for connection timeouts. Implement a retry mechanism for initial connection attempts to handle database cold starts. Ensure the global instance is reused correctly in development to prevent connection pool exhaustion.",
            "status": "in-progress",
            "testStrategy": "Simulate a database downtime during app startup and verify the application retries rather than crashing immediately.",
            "parentId": "undefined",
            "updatedAt": "2025-12-20T18:54:38.709Z"
          },
          {
            "id": 5,
            "title": "Production Build Verification & Cleanup",
            "description": "Verify that production builds with mock mode disabled function correctly and contain no active mock paths.",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "Execute a production build (`npm run build`). Set `NEXT_PUBLIC_MOCK_MODE=false`. Manually verify critical paths (scraping, generation) fail gracefully or work with real data, rather than returning cached mocks. Ensure no sensitive mock data remains in the client bundle.",
            "status": "pending",
            "testStrategy": "Inspect the build output and run an E2E test suite against the production build with mock mode disabled.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2025-12-20T18:56:22.812Z"
      },
      {
        "id": "35",
        "title": "Design System Update: Deep Space Theme",
        "description": "Implement the new visual identity including color palette and glassmorphism utilities.",
        "details": "Update `tailwind.config.js` to include the 'Deep Space' palette (Slate-950 background, Electric Green accents). Create utility classes or components for the 'Frost Glass' effect (translucent surfaces with backdrop blur). Standardize typography and spacing for the new aesthetic.",
        "testStrategy": "Visual regression testing on a style guide page to ensure colors and glass effects render correctly across browsers.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Configure Deep Space Color Palette",
            "description": "Update the Tailwind configuration to include the specific color codes for the Deep Space theme.",
            "dependencies": [],
            "details": "Modify `tailwind.config.js` to extend the theme colors. Add `deep-space` (Slate-950 hex) as the background base and `electric-green` as the primary accent color. Ensure semantic naming for text colors (primary, secondary, muted) based on these new hues.",
            "status": "done",
            "testStrategy": "Inspect the resolved Tailwind config to verify the new color keys exist.",
            "parentId": "undefined",
            "updatedAt": "2025-12-20T19:10:29.389Z"
          },
          {
            "id": 2,
            "title": "Standardize Typography and Spacing",
            "description": "Define the font stack and spacing scale to match the new aesthetic requirements.",
            "dependencies": [
              1
            ],
            "details": "Update `tailwind.config.js` to set the font family (e.g., Inter or a monospaced font for technical feel). Define a custom spacing scale or alias existing spacing utilities to semantic names like `space-layout-sm` and `space-layout-md` to ensure consistency across the app.",
            "status": "done",
            "testStrategy": "Check computed styles on a test element to ensure correct font-family and margin application.",
            "parentId": "undefined",
            "updatedAt": "2025-12-20T19:11:06.229Z"
          },
          {
            "id": 3,
            "title": "Implement Frost Glass Utilities",
            "description": "Create reusable CSS classes or a Tailwind plugin for the glassmorphism effect.",
            "dependencies": [
              1
            ],
            "details": "Develop a `.glass-panel` utility class that applies `backdrop-filter: blur()`, semi-transparent background colors (using rgba or tailwind opacity modifiers), and subtle white borders. Ensure fallback styles for browsers that do not support backdrop-filter.",
            "status": "done",
            "testStrategy": "Render a div with the class over an image and verify the blur effect visually.",
            "parentId": "undefined",
            "updatedAt": "2025-12-20T19:11:08.672Z"
          },
          {
            "id": 4,
            "title": "Update Core UI Components",
            "description": "Refactor base components like Buttons, Cards, and Inputs to utilize the new design tokens.",
            "dependencies": [
              2,
              3
            ],
            "details": "Update the `Button`, `Card`, and `Input` React components to use the new `electric-green` accents and `glass-panel` styles. Ensure hover states and focus rings align with the Deep Space theme (e.g., glowing green borders on focus).",
            "status": "done",
            "testStrategy": "Interactive testing of components in Storybook to verify hover and focus states.",
            "parentId": "undefined",
            "updatedAt": "2025-12-20T19:11:11.001Z"
          },
          {
            "id": 5,
            "title": "Create Style Guide and Visual Tests",
            "description": "Build a documentation page showcasing the new theme and set up visual regression tests.",
            "dependencies": [
              4
            ],
            "details": "Create a route `/design-system` that renders all color swatches, typography samples, and glass components. Configure a visual regression tool (like Playwright screenshot comparison) to snapshot this page and ensure the theme renders correctly across different viewports.",
            "status": "done",
            "testStrategy": "Run the visual regression suite and verify that snapshots match the design mockups.",
            "parentId": "undefined",
            "updatedAt": "2025-12-20T19:11:40.119Z"
          }
        ],
        "updatedAt": "2025-12-20T19:11:40.119Z"
      },
      {
        "id": "36",
        "title": "App Shell & Navigation Redesign",
        "description": "Replace the sidebar with a floating 'Pill' navigation interface.",
        "details": "Remove the existing sidebar component. Implement a responsive floating 'Pill' navigation bar. Update the main `Layout.tsx` to accommodate the new navigation structure and apply the Slate-950 background globally. Ensure z-indexing handles the floating elements correctly over content.",
        "testStrategy": "Verify navigation functionality on desktop and mobile viewports. Ensure content is not obscured by the floating pill.",
        "priority": "medium",
        "dependencies": [
          "35"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Deprecate Legacy Sidebar Component",
            "description": "Remove the existing Sidebar component and clean up the layout grid that accommodates it.",
            "dependencies": [],
            "details": "Delete the `Sidebar` component file. Remove the import and usage from `Layout.tsx`. Refactor the main layout container to remove the CSS Grid or Flexbox column previously reserved for the sidebar, allowing the main content to span the full width.",
            "status": "pending",
            "testStrategy": "Verify the application loads without the sidebar and the main content area expands to fill the viewport width.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Apply Deep Space Background to Layout",
            "description": "Update the global layout wrapper to utilize the new Slate-950 background color.",
            "dependencies": [
              1
            ],
            "details": "Modify `Layout.tsx` (or the root layout file) to apply the `bg-slate-950` class globally. Ensure text colors default to the appropriate light contrast color defined in the Design System (Task 35) to remain visible against the dark background.",
            "status": "pending",
            "testStrategy": "Visual check to ensure the background is the correct hex code (#020617 for Slate-950) and covers the entire viewport height.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Develop Floating Pill Navigation Component",
            "description": "Create the new 'Pill' navigation component using glassmorphism styles.",
            "dependencies": [
              2
            ],
            "details": "Create `components/Navigation/PillNav.tsx`. Implement the container with `fixed`, rounded-full, and the 'Frost Glass' utility classes (backdrop-blur, translucent background). Add navigation items (Dashboard, Jobs, Settings) using icons.",
            "status": "pending",
            "testStrategy": "Render the component in isolation (Storybook or temporary page) to verify the glass effect and icon alignment.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Integrate Navigation and Handle Z-Indexing",
            "description": "Place the Pill Navigation into the main layout and manage stacking contexts.",
            "dependencies": [
              3
            ],
            "details": "Import `PillNav` into `Layout.tsx`. Position it fixed at the bottom-center of the screen. Set a high `z-index` (e.g., z-50) to ensure it floats above all scrollable content. Add bottom padding to the main content area so the last items are not obscured by the nav.",
            "status": "pending",
            "testStrategy": "Scroll a long page of content to ensure the navigation stays fixed on top and does not hide the very last element of the page content.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement Active States and Mobile Responsiveness",
            "description": "Add logic for highlighting the current route and adjust sizing for mobile devices.",
            "dependencies": [
              4
            ],
            "details": "Use the router hook (e.g., `usePathname`) to apply the 'Electric Green' accent color to the active navigation icon. Adjust the Pill's width and icon spacing using Tailwind responsive prefixes to ensure touch targets are accessible on mobile devices.",
            "status": "pending",
            "testStrategy": "Click through all links to verify the active state updates correctly. Test on a mobile viewport simulation to ensure buttons are easily clickable.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2025-12-20T19:12:43.822Z"
      },
      {
        "id": "37",
        "title": "Workspace Data Model Implementation",
        "description": "Update Prisma schema to support the Candidate CRM workflow.",
        "details": "Extend `schema.prisma` to include `Workspace` (Application Record), `Artifact` (stored resumes/cover letters), and `WarRoomNote` models. Add status enums (Applied, Follow-up, Dormant, Archived) and timestamp fields for lifecycle tracking. Run migrations.",
        "testStrategy": "Run `npx prisma migrate dev`. Verify relationships between User, Job, and Workspace in Prisma Studio.",
        "priority": "high",
        "dependencies": [
          "34"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Define Application Status Enum and Workspace Model",
            "description": "Add the status enum and the main Workspace model to the Prisma schema to track application states.",
            "dependencies": [],
            "details": "Edit `schema.prisma`. Define `enum ApplicationStatus { APPLIED, FOLLOW_UP, DORMANT, ARCHIVED }`. Define `model Workspace` with fields: `id` (CUID/UUID), `createdAt`, `updatedAt`, `status` (default APPLIED), `userId`, and `jobId`.",
            "status": "done",
            "testStrategy": "Run `npx prisma format` to ensure syntax is valid.",
            "parentId": "undefined",
            "updatedAt": "2025-12-20T19:13:19.610Z"
          },
          {
            "id": 2,
            "title": "Define Artifact Model for Document Snapshots",
            "description": "Create the Artifact model to store immutable copies of resumes and cover letters linked to a workspace.",
            "dependencies": [
              1
            ],
            "details": "Add `model Artifact` to `schema.prisma`. Include fields: `id`, `type` (String or Enum: RESUME, COVER_LETTER), `storagePath` (String), `snapshotDate` (DateTime default now), and a foreign key relation to `Workspace`.",
            "status": "done",
            "testStrategy": "Verify the relation syntax allows one Workspace to have multiple Artifacts.",
            "parentId": "undefined",
            "updatedAt": "2025-12-20T19:13:21.605Z"
          },
          {
            "id": 3,
            "title": "Define WarRoomNote Model",
            "description": "Create the model for storing user notes associated with specific applications within the CRM.",
            "dependencies": [
              1
            ],
            "details": "Add `model WarRoomNote` to `schema.prisma`. Include fields: `id`, `content` (String/Text), `createdAt`, `updatedAt`, and a foreign key relation to `Workspace`.",
            "status": "done",
            "testStrategy": "Verify the relation syntax allows one Workspace to have multiple WarRoomNotes.",
            "parentId": "undefined",
            "updatedAt": "2025-12-20T19:13:23.596Z"
          },
          {
            "id": 4,
            "title": "Establish Inverse Relations in User and Job Models",
            "description": "Update the existing User and Job models to include the necessary inverse relations to the new Workspace model.",
            "dependencies": [
              1
            ],
            "details": "Update the `User` model to include `workspaces Workspace[]`. Update the `Job` model to include `applications Workspace[]`. Ensure referential actions (e.g., onDelete: Cascade) are set correctly for the User relation.",
            "status": "done",
            "testStrategy": "Run `npx prisma validate` to ensure the relational graph is complete and valid.",
            "parentId": "undefined",
            "updatedAt": "2025-12-20T19:13:38.994Z"
          },
          {
            "id": 5,
            "title": "Execute Database Migration and Generate Client",
            "description": "Apply the schema changes to the local database and regenerate the Prisma client for type safety.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Run `npx prisma migrate dev --name init_workspace_crm`. This command should create the SQL migration file, apply it to the database, and automatically run `prisma generate`.",
            "status": "done",
            "testStrategy": "Open Prisma Studio (`npx prisma studio`) and verify that the new tables (Workspace, Artifact, WarRoomNote) exist and relations are visible.",
            "parentId": "undefined",
            "updatedAt": "2025-12-20T19:15:27.732Z"
          }
        ],
        "updatedAt": "2025-12-20T19:15:27.732Z"
      },
      {
        "id": "38",
        "title": "Ingest Pipeline Unification",
        "description": "Standardize data flow from API to Database to UI.",
        "details": "Refactor backend routes to ensure all incoming job data goes `Raw API -> Normalization -> Prisma`. Update UI components to fetch strictly from the database, removing any direct API-to-UI paths. Ensure geocoding happens during the normalization phase.",
        "testStrategy": "Trigger a job scrape and verify data persists in Postgres before appearing in the UI.",
        "priority": "high",
        "dependencies": [
          "37"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Data Normalization and Geocoding Service",
            "description": "Create a backend service to transform raw scrape data into the standard schema and resolve locations.",
            "dependencies": [],
            "details": "Develop a `normalizeJobData` utility. Integrate the geocoding provider (e.g., Google Maps API or Mapbox) to convert location strings into coordinates immediately upon data receipt. Ensure the output matches the Prisma `Job` model interface strictly.",
            "status": "done",
            "testStrategy": "Unit test the normalization function with mock raw payloads and mock geocoding responses to verify correct schema transformation.",
            "parentId": "undefined",
            "updatedAt": "2025-12-20T19:16:08.081Z"
          },
          {
            "id": 2,
            "title": "Refactor Backend Ingestion Routes",
            "description": "Update ingestion API endpoints to enforce the Normalization -> Prisma persistence flow.",
            "dependencies": [
              1
            ],
            "details": "Modify the job scraper entry points (e.g., `/api/ingest`). Replace any direct return logic with a call to the normalization service followed by `prisma.job.create` or `upsert`. Ensure no data is returned to the client until it is safely stored in Postgres.",
            "status": "done",
            "testStrategy": "Post raw data to the ingestion endpoint and verify the record exists in the database via Prisma Studio or SQL query.",
            "parentId": "undefined",
            "updatedAt": "2025-12-20T19:17:11.072Z"
          },
          {
            "id": 3,
            "title": "Develop Database-Backed Job Retrieval API",
            "description": "Create or update API endpoints for the frontend to fetch persisted job data.",
            "dependencies": [
              2
            ],
            "details": "Implement `GET /api/jobs` with support for pagination and filtering. This endpoint must serve as the single source of truth for the UI, retrieving data solely from the Postgres database, including the newly added geocoordinates.",
            "status": "done",
            "testStrategy": "Call the retrieval endpoint and verify it returns the exact data structure stored in the previous step.",
            "parentId": "undefined",
            "updatedAt": "2025-12-20T19:17:41.528Z"
          },
          {
            "id": 4,
            "title": "Migrate UI Components to Database Source",
            "description": "Refactor frontend components to fetch data from the database API rather than accepting raw scrape results.",
            "dependencies": [
              3
            ],
            "details": "Update the Job Dashboard and List components. Remove props or context that allowed passing 'live' scrape data directly to the view. Implement data fetching hooks (e.g., SWR or React Query) targeting the endpoints created in subtask 3.",
            "status": "done",
            "testStrategy": "Load the dashboard and verify jobs appear. Check network tab to ensure data comes from `/api/jobs` and not the scrape trigger response.",
            "parentId": "undefined",
            "updatedAt": "2025-12-20T19:18:21.525Z"
          },
          {
            "id": 5,
            "title": "Deprecate Direct API-to-UI Paths and Verify Pipeline",
            "description": "Remove legacy code enabling direct data passing and perform end-to-end pipeline verification.",
            "dependencies": [
              4
            ],
            "details": "Delete any unused 'preview' routes or logic that bypassed the database. Conduct a full flow test: Trigger a new job scrape, wait for backend processing, and confirm the job appears in the UI via the database fetch without page reloads if using optimistic updates or revalidation.",
            "status": "done",
            "testStrategy": "Run a regression test suite to ensure no 'ghost' data (data not in DB) can be displayed in the application.",
            "parentId": "undefined",
            "updatedAt": "2025-12-20T23:25:24.582Z"
          }
        ],
        "updatedAt": "2025-12-20T23:25:24.582Z"
      },
      {
        "id": "39",
        "title": "Workspace Creation & Artifact Locking",
        "description": "Implement logic to spawn a Workspace and snapshot documents upon application.",
        "details": "Create a backend service that triggers when a user applies. It must: 1. Create a `Workspace` record. 2. Snapshot the specific PDF resume and Cover Letter content used. 3. Store these as immutable `Artifact` records linked to the Workspace.",
        "testStrategy": "Apply to a job, then update the user's generic resume. Verify the Workspace retains the *original* version.",
        "priority": "high",
        "dependencies": [
          "37"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Application API Endpoint",
            "description": "Set up the backend controller to handle job application requests.",
            "dependencies": [],
            "details": "Create a POST route (e.g., /api/workspaces/apply) that accepts `jobId`, `resumeId`, and `coverLetterId`. Implement validation to ensure the user exists, the job is open, and the user has not already applied to this specific job.",
            "status": "done",
            "testStrategy": "Send valid and invalid payloads via Postman to verify validation logic and 400/409 error responses.",
            "parentId": "undefined",
            "updatedAt": "2025-12-20T23:29:59.912Z"
          },
          {
            "id": 2,
            "title": "Implement Document Snapshot Service",
            "description": "Develop a utility to duplicate file assets for immutable storage.",
            "dependencies": [
              1
            ],
            "details": "Create a service function `snapshotDocument(sourceUrl)` that copies the file from the user's mutable storage path to a permanent `artifacts/` directory in the object storage (e.g., S3/Blob). This ensures the file remains unchanged even if the user updates their profile.",
            "status": "done",
            "testStrategy": "Unit test the service with a mock file; verify the file exists at the new location and has a distinct URL.",
            "parentId": "undefined",
            "updatedAt": "2025-12-20T23:30:01.699Z"
          },
          {
            "id": 3,
            "title": "Implement Workspace Transaction Logic",
            "description": "Write the database transaction to create the Workspace and Artifacts atomically.",
            "dependencies": [
              2
            ],
            "details": "Use `prisma.$transaction` to ensure data integrity. The transaction should: 1. Create the `Workspace` record with status 'Applied'. 2. Create `Artifact` records for the resume and cover letter using the new snapshot URLs generated in the previous step.",
            "status": "done",
            "testStrategy": "Run the transaction logic; verify that if the Artifact creation fails, the Workspace record is not created (rollback).",
            "parentId": "undefined",
            "updatedAt": "2025-12-20T23:30:03.496Z"
          },
          {
            "id": 4,
            "title": "Error Handling and Cleanup",
            "description": "Implement rollback logic for file storage if the database transaction fails.",
            "dependencies": [
              3
            ],
            "details": "Wrap the application logic in a try/catch block. If the Prisma transaction fails, ensure that the copied files in the `artifacts/` storage bucket are deleted to prevent orphaned files and storage bloat.",
            "status": "done",
            "testStrategy": "Simulate a database error after file copy; verify that the cleanup function triggers and removes the copied file.",
            "parentId": "undefined",
            "updatedAt": "2025-12-20T23:30:05.302Z"
          },
          {
            "id": 5,
            "title": "Verify Artifact Immutability",
            "description": "Create an integration test to prove the snapshot logic works as intended.",
            "dependencies": [
              4
            ],
            "details": "Write a test script that: 1. Submits an application with 'Resume V1'. 2. Updates the user's profile to 'Resume V2'. 3. Fetches the Workspace and asserts that the linked Artifact still points to the content of 'Resume V1'.",
            "status": "done",
            "testStrategy": "Execute the integration test suite and ensure the checksum or content of the artifact matches the original file.",
            "parentId": "undefined",
            "updatedAt": "2025-12-20T23:30:07.096Z"
          }
        ],
        "updatedAt": "2025-12-20T23:30:07.096Z"
      },
      {
        "id": "40",
        "title": "War Room UI & Notes Integration",
        "description": "Build the detailed view for managing a specific job application.",
        "details": "Develop the `workspace/[id]` page. Include a Markdown editor for 'War Room' notes. Display the locked Artifacts (Resume/Cover Letter) for reference. Implement status toggles. Apply 'Deep Space' styling.",
        "testStrategy": "Create, edit, and save markdown notes. Verify persistence. Check that artifacts are viewable/downloadable.",
        "priority": "medium",
        "dependencies": [
          "36",
          "39"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Scaffold Workspace Page & Data Fetching",
            "description": "Create the dynamic route structure and implement initial data fetching for the specific job application.",
            "dependencies": [],
            "details": "Initialize `app/workspace/[id]/page.tsx`. Implement the server-side logic to fetch the specific job application record by ID, including relations to the specific Resume and Cover Letter versions used. Set up the basic CSS Grid layout for the War Room interface.",
            "status": "done",
            "testStrategy": "Verify the page loads for a valid ID and returns a 404 for an invalid ID. Check that the application title and company name render correctly.",
            "parentId": "undefined",
            "updatedAt": "2025-12-20T23:37:03.235Z"
          },
          {
            "id": 2,
            "title": "Implement Read-Only Artifact Viewer",
            "description": "Build the UI component to display the locked Resume and Cover Letter for reference.",
            "dependencies": [
              1
            ],
            "details": "Create a split-view or tabbed panel to display the content of the linked artifacts. Since these are 'locked' snapshots, the view must be read-only. Support rendering of Markdown content or PDF embedding depending on the artifact storage format.",
            "status": "done",
            "testStrategy": "Load a workspace with known artifacts. Verify the content matches the database record and is not editable.",
            "parentId": "undefined",
            "updatedAt": "2025-12-20T23:37:05.061Z"
          },
          {
            "id": 3,
            "title": "Integrate Markdown Editor for Notes",
            "description": "Embed a Markdown editor component for the 'War Room' notes section.",
            "dependencies": [
              1
            ],
            "details": "Integrate a library such as `react-markdown`, `tiptap`, or `monaco-editor`. Configure the editor to allow writing free-form notes regarding the application process. Ensure the editor fits within the 'Deep Space' dark theme UI.",
            "status": "done",
            "testStrategy": "Type text into the editor, apply formatting (bold, list), and verify the UI renders the markdown preview correctly.",
            "parentId": "undefined",
            "updatedAt": "2025-12-20T23:37:06.904Z"
          },
          {
            "id": 4,
            "title": "Connect Persistence & Status Logic",
            "description": "Implement the API connections for saving notes and updating the application status.",
            "dependencies": [
              3
            ],
            "details": "Create API endpoints or server actions to handle `PATCH` requests for the application. Implement auto-save or a manual save button for the Markdown notes. Add a status dropdown/toggle (e.g., Applied -> Interviewing) that updates the database immediately.",
            "status": "done",
            "testStrategy": "Edit notes and reload the page to ensure persistence. Change the status toggle and verify the change is reflected in the database.",
            "parentId": "undefined",
            "updatedAt": "2025-12-20T23:37:08.700Z"
          },
          {
            "id": 5,
            "title": "Apply Deep Space Styling & Polish",
            "description": "Finalize the visual design using the project's specific theme variables.",
            "dependencies": [
              2,
              4
            ],
            "details": "Apply the 'Deep Space' color palette (dark backgrounds, glassmorphism panels, neon accents). Ensure the layout is responsive, stacking the Artifact Viewer and Notes editor on smaller screens. Add loading skeletons for data fetching states.",
            "status": "done",
            "testStrategy": "Visual inspection across desktop and mobile viewports. Verify contrast ratios and theme consistency.",
            "parentId": "undefined",
            "updatedAt": "2025-12-20T23:37:10.542Z"
          }
        ],
        "updatedAt": "2025-12-20T23:37:10.542Z"
      },
      {
        "id": "41",
        "title": "Triage Feed Implementation",
        "description": "Create the 'Inbox Zero' workflow for new job listings.",
        "details": "Develop a 'New Jobs' feed optimized for speed. Implement 'Trash' (hide) and 'Workspace' (save/apply) actions. Add keyboard shortcuts for rapid processing. Ensure the feed only shows jobs not yet acted upon.",
        "testStrategy": "Load feed, trash 5 items, refresh. Verify trashed items do not reappear.",
        "priority": "medium",
        "dependencies": [
          "36",
          "38"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Unprocessed Jobs Query",
            "description": "Create the backend logic to fetch jobs that have not yet been acted upon by the user.",
            "dependencies": [],
            "details": "Define a Prisma query filtering out jobs that already exist in the `Workspace` table (saved) or a `HiddenJobs` table (trashed) for the current user. Ensure the query supports pagination or infinite scroll cursors.",
            "status": "pending",
            "testStrategy": "Unit test the query with a seeded database containing a mix of acted-upon and new jobs to ensure only new ones are returned.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Develop Triage Feed UI Component",
            "description": "Build the frontend component to display the stream of new job listings.",
            "dependencies": [
              1
            ],
            "details": "Create a responsive list view component. Each item should display Job Title, Company, Location, and Salary. Handle loading states and an 'Inbox Zero' empty state when no jobs remain.",
            "status": "pending",
            "testStrategy": "Render the component with mock data using Storybook or a test runner to verify data binding and layout.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement Trash Action Logic",
            "description": "Enable users to hide jobs they are not interested in so they do not reappear.",
            "dependencies": [
              2
            ],
            "details": "Create a backend mutation to add a job to a `HiddenJobs` table (or update a status flag). Add a 'Trash' button to the UI card that triggers this mutation.",
            "status": "pending",
            "testStrategy": "Click the trash button, verify the API call is made, and confirm the item is filtered out on a subsequent page reload.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement Save to Workspace Action",
            "description": "Enable users to move interesting jobs to their active workspace for application.",
            "dependencies": [
              2
            ],
            "details": "Create a backend mutation to create a new `Workspace` entity linked to the Job and User with a status of 'To Apply'. Add a 'Save' button to the UI card.",
            "status": "pending",
            "testStrategy": "Click the save button, verify the API call, and check the database to ensure a Workspace record was created.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Integrate Keyboard Shortcuts and Optimistic Updates",
            "description": "Optimize the workflow for speed using keyboard navigation and immediate UI feedback.",
            "dependencies": [
              3,
              4
            ],
            "details": "Bind keys (e.g., 'X' for Trash, 'S' for Save) to the actions defined in previous tasks. Implement optimistic state updates to remove cards instantly from the DOM before the server responds.",
            "status": "pending",
            "testStrategy": "Use Cypress to simulate rapid keystrokes and verify that the UI updates immediately while network requests complete in the background.",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Develop Triage Feed API Endpoint",
            "description": "Create the backend logic to fetch unacted job listings for the current user.",
            "dependencies": [],
            "details": "Implement a tRPC procedure `getTriageJobs`. The query must select from the `Job` table while performing an anti-join or `NOT EXISTS` check against the `Workspace` (saved) and `HiddenJobs` (trashed) tables for the authenticated user. Implement cursor-based pagination to handle large datasets efficiently.",
            "status": "pending",
            "testStrategy": "Unit test the query with a mock database: insert 10 jobs, hide 2, save 2, and verify the endpoint returns exactly 6 specific jobs.",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "Build Triage Feed UI Component",
            "description": "Create the frontend component to display the stream of new job cards.",
            "dependencies": [
              6
            ],
            "details": "Develop `TriageFeed.tsx`. Use a card layout displaying Job Title, Company, Location, Salary, and Posted Date. Implement a loading skeleton state while fetching data from the API. Ensure the layout is responsive and centered for focused reading.",
            "status": "pending",
            "testStrategy": "Verify component renders job data correctly using Storybook. Check that the loading skeleton appears before data arrives.",
            "parentId": "undefined"
          },
          {
            "id": 8,
            "title": "Implement Trash Action Logic",
            "description": "Enable users to hide jobs they are not interested in using a 'Trash' action.",
            "dependencies": [
              6,
              7
            ],
            "details": "Create a `hideJob` mutation that adds a record to the `HiddenJobs` table. On the frontend, add a 'Trash' icon button to the job card. Implement optimistic UI updates to remove the card from the DOM immediately upon clicking, without waiting for server confirmation.",
            "status": "pending",
            "testStrategy": "Click trash on a job, refresh the page, and verify the job does not reappear in the feed.",
            "parentId": "undefined"
          },
          {
            "id": 9,
            "title": "Implement Workspace Save Action",
            "description": "Enable users to move interesting jobs to their Workspace for later application.",
            "dependencies": [
              6,
              7
            ],
            "details": "Create a `saveToWorkspace` mutation that creates a new record in the `Workspace` table with an initial status of 'Inbox' or 'To Apply'. Add a 'Save' button to the UI. Like the trash action, remove the item from the Triage feed immediately upon interaction.",
            "status": "pending",
            "testStrategy": "Click save on a job, navigate to the Workspace view, and verify the job is listed there with the correct status.",
            "parentId": "undefined"
          },
          {
            "id": 10,
            "title": "Add Keyboard Shortcuts for Rapid Triage",
            "description": "Implement hotkeys to allow mouse-free processing of the feed (Inbox Zero style).",
            "dependencies": [
              8,
              9
            ],
            "details": "Integrate a library like `react-hotkeys-hook`. Map 'S' or 'ArrowRight' to trigger the Save action, and 'X' or 'ArrowLeft' to trigger the Trash action. Ensure the focus state automatically advances to the next card in the list after an action is performed.",
            "status": "pending",
            "testStrategy": "Manually test processing a queue of 10 jobs using only the keyboard. Verify that no mouse interaction is required to clear the feed.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2025-12-20T23:59:42.985Z"
      },
      {
        "id": "42",
        "title": "Lifecycle Automation Service",
        "description": "Implement background jobs for application status updates.",
        "details": "Set up a cron job (e.g., Vercel Cron or Node-cron). Logic: If status unchanged > 7 days, set 'Follow-up' flag. If > 30 days, set 'Dormant'. If > 60 days, move to 'Archived'. Ensure this runs daily.",
        "testStrategy": "Seed DB with applications having old timestamps. Run the job manually. Verify status transitions.",
        "priority": "medium",
        "dependencies": [
          "37"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Lifecycle Automation API Endpoint",
            "description": "Set up a secure API route to handle the lifecycle automation logic.",
            "dependencies": [],
            "details": "Create a new API route (e.g., `/api/cron/lifecycle`) to serve as the entry point for the background job. Implement authentication middleware to verify a `CRON_SECRET` header to prevent unauthorized external access to this endpoint.",
            "status": "done",
            "testStrategy": "Send a POST request to the endpoint with and without the secret token to verify security.",
            "parentId": "undefined",
            "updatedAt": "2025-12-20T23:32:31.155Z"
          },
          {
            "id": 2,
            "title": "Implement Follow-up Flag Logic",
            "description": "Develop the logic to identify applications unchanged for over 7 days.",
            "dependencies": [
              1
            ],
            "details": "Write a database query to select applications where `updatedAt` is older than 7 days and the current status is active. Update these records to set the `needsFollowUp` flag to true, without changing the primary status.",
            "status": "done",
            "testStrategy": "Unit test the query with mock dates (6 days vs 8 days) to ensure the flag is applied correctly.",
            "parentId": "undefined",
            "updatedAt": "2025-12-20T23:32:32.936Z"
          },
          {
            "id": 3,
            "title": "Implement Dormant and Archived Transitions",
            "description": "Develop the logic to transition applications to Dormant or Archived status based on age.",
            "dependencies": [
              2
            ],
            "details": "Implement logic to find applications unchanged for > 30 days and update status to 'Dormant'. Find applications unchanged for > 60 days and update status to 'Archived'. Ensure the 60-day rule takes precedence over the 30-day rule if both apply.",
            "status": "done",
            "testStrategy": "Unit test with mock dates (29, 31, 59, 61 days) to verify correct status assignment.",
            "parentId": "undefined",
            "updatedAt": "2025-12-20T23:32:34.776Z"
          },
          {
            "id": 4,
            "title": "Configure Daily Cron Schedule",
            "description": "Set up the scheduler configuration to trigger the automation daily.",
            "dependencies": [
              1
            ],
            "details": "Configure the cron schedule (e.g., via `vercel.json` crons array or a node-cron instance) to execute the lifecycle API endpoint once every 24 hours (e.g., at 00:00 UTC). Ensure the environment variables for the secret key are accessible to the scheduler.",
            "status": "done",
            "testStrategy": "Verify configuration syntax and deployment logs to ensure the job is registered.",
            "parentId": "undefined",
            "updatedAt": "2025-12-20T23:32:36.528Z"
          },
          {
            "id": 5,
            "title": "Integration Testing and Validation",
            "description": "Perform end-to-end testing with seeded data to verify the full lifecycle flow.",
            "dependencies": [
              3,
              4
            ],
            "details": "Create a seed script that populates the database with applications having `updatedAt` timestamps of 8, 31, and 61 days ago. Trigger the cron job manually and verify that the database records reflect the expected 'Follow-up', 'Dormant', and 'Archived' states.",
            "status": "done",
            "testStrategy": "Run the seed script, execute the job, and assert database state matches expected outcomes.",
            "parentId": "undefined",
            "updatedAt": "2025-12-20T23:32:38.304Z"
          }
        ],
        "updatedAt": "2025-12-20T23:32:38.304Z"
      },
      {
        "id": "43",
        "title": "Dashboard Analytics & Visualization",
        "description": "Integrate charts to show campaign velocity and health.",
        "details": "Integrate `recharts` or `@tremor/react`. Create a 'Velocity Graph' (applications sent per week) and a Pipeline Health chart (Active vs Dormant vs Archived). Embed these into the main dashboard view.",
        "testStrategy": "Verify charts render correctly with empty data, single data point, and large datasets.",
        "priority": "low",
        "dependencies": [
          "36",
          "37"
        ],
        "status": "in-progress",
        "subtasks": [
          {
            "id": 1,
            "title": "Install Visualization Library and Setup Component Structure",
            "description": "Install the chosen charting library and set up the base container for analytics components.",
            "dependencies": [],
            "details": "Install `@tremor/react` (or `recharts`) via npm/yarn. Configure Tailwind CSS content paths to include the library's styles if using Tremor. Create a scaffold component `components/dashboard/AnalyticsSection.tsx` to house the future charts.",
            "status": "done",
            "testStrategy": "Verify that the library installs without peer dependency conflicts and the empty container component renders on the dashboard without errors.",
            "parentId": "undefined",
            "updatedAt": "2025-12-21T16:43:37.292Z"
          },
          {
            "id": 2,
            "title": "Implement Data Aggregation Logic for Velocity",
            "description": "Create the backend logic or utility functions to aggregate application data by week.",
            "dependencies": [
              1
            ],
            "details": "Develop a function `getWeeklyApplicationVelocity` that queries the application table, groups records by creation date (ISO week), and fills in missing weeks with zero values to ensure a continuous timeline for the visualization.",
            "status": "done",
            "testStrategy": "Unit test the aggregation function with mock data sets, ensuring weeks with zero applications are correctly represented in the output array.",
            "parentId": "undefined",
            "updatedAt": "2025-12-21T16:43:47.044Z"
          },
          {
            "id": 3,
            "title": "Develop Velocity Graph Component",
            "description": "Build the UI component to display the number of applications sent per week.",
            "dependencies": [
              2
            ],
            "details": "Implement a BarChart or AreaChart using the data from the aggregation logic. Configure the X-axis for dates and Y-axis for count. Apply the 'Deep Space' color palette to the chart elements and implement a custom tooltip.",
            "status": "done",
            "testStrategy": "Render the component with a mock 12-week dataset and verify that the bars/lines correspond to the correct values.",
            "parentId": "undefined",
            "updatedAt": "2025-12-21T16:44:35.835Z"
          },
          {
            "id": 4,
            "title": "Develop Pipeline Health Chart Component",
            "description": "Build the UI component to visualize the distribution of application statuses.",
            "dependencies": [
              1
            ],
            "details": "Implement a DonutChart or PieChart that accepts counts for 'Active', 'Dormant', and 'Archived' statuses. Ensure the colors are semantically appropriate (e.g., Green for Active, Grey for Archived). Add a legend and handle the empty state.",
            "status": "pending",
            "testStrategy": "Verify the chart renders correctly with 100% in one category, split across categories, and with an empty dataset.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Integrate Charts into Main Dashboard Layout",
            "description": "Embed the new analytics components into the main dashboard page with responsive styling.",
            "dependencies": [
              3,
              4
            ],
            "details": "Import the Velocity and Health components into the main Dashboard view. Use CSS Grid to arrange them (e.g., side-by-side on desktop, stacked on mobile). Ensure consistent spacing, padding, and background contrast against the dashboard container.",
            "status": "done",
            "testStrategy": "Check the layout responsiveness on mobile, tablet, and desktop viewports to ensure charts resize without breaking the UI.",
            "parentId": "undefined",
            "updatedAt": "2025-12-21T16:44:38.034Z"
          },
          {
            "id": 6,
            "title": "Install Charting Library and Setup",
            "description": "Install the chosen visualization library and configure base component structures.",
            "dependencies": [],
            "details": "Install `recharts` (or `@tremor/react` based on preference) via npm/yarn. Create a `components/analytics` directory. Establish a base theme configuration to ensure charts inherit the application's 'Deep Space' color palette and typography settings.",
            "status": "pending",
            "testStrategy": "Verify that the library is installed correctly and a 'Hello World' chart renders without console errors.",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "Implement Analytics Data Aggregation Logic",
            "description": "Create utility functions to transform raw application data into chart-friendly formats.",
            "dependencies": [],
            "details": "Develop a `useAnalyticsData` hook or utility function. This must fetch all job applications and perform two aggregations: 1) Group by creation date (weekly buckets) for velocity, and 2) Group by current status (Active, Dormant, Archived) for health metrics.",
            "status": "pending",
            "testStrategy": "Unit test the aggregation logic with mock data sets to ensure correct counting and date grouping.",
            "parentId": "undefined"
          },
          {
            "id": 8,
            "title": "Develop Velocity Graph Component",
            "description": "Build the visual component to display application frequency over time.",
            "dependencies": [
              6,
              7
            ],
            "details": "Create `VelocityChart.tsx`. Implement a Bar or Area chart showing 'Applications Sent' on the Y-axis and 'Week' on the X-axis. Ensure tooltips display exact counts and dates. Handle cases where specific weeks have zero activity.",
            "status": "pending",
            "testStrategy": "Render the component with data spanning multiple weeks and verify the axis scaling and tooltip interactions.",
            "parentId": "undefined"
          },
          {
            "id": 9,
            "title": "Develop Pipeline Health Chart Component",
            "description": "Build the visual component to display the distribution of application statuses.",
            "dependencies": [
              6,
              7
            ],
            "details": "Create `PipelineHealthChart.tsx`. Implement a Donut or Pie chart visualizing the ratio of Active vs. Dormant vs. Archived applications. Use distinct colors for each status (e.g., Green for Active, Grey for Archived). Include a legend.",
            "status": "pending",
            "testStrategy": "Render the component with various status distributions, including 100% in one category, to check visual integrity.",
            "parentId": "undefined"
          },
          {
            "id": 10,
            "title": "Integrate Charts into Dashboard View",
            "description": "Embed the analytics components into the main dashboard layout.",
            "dependencies": [
              8,
              9
            ],
            "details": "Import `VelocityChart` and `PipelineHealthChart` into the main Dashboard page. Create a responsive grid layout to display them. Implement 'Empty State' placeholders if the user has no application data yet. Ensure the layout adjusts for mobile screens.",
            "status": "done",
            "testStrategy": "Check the dashboard on different screen sizes. Verify that charts resize correctly and empty states appear when the database is clear.",
            "parentId": "undefined",
            "updatedAt": "2025-12-22T00:49:44.967Z"
          }
        ],
        "updatedAt": "2025-12-22T00:49:44.967Z"
      },
      {
        "id": "44",
        "title": "Implement 'Undo' Outbound Queue for Job Triage",
        "description": "Develop a client-side buffering system for triage actions to prevent accidental swipes, featuring a temporary queue, undo toasts, and bulk persistence.",
        "details": "1. **State Management**: Implement a `TriageQueueContext` (or Zustand store) to hold an array of `PendingAction` objects (`{ jobId, action: 'TRASH' | 'WORKSPACE', timestamp }`).\n2. **Optimistic UI Updates**: Modify the Triage Feed (Task 41) to visually remove items immediately upon interaction without awaiting a backend response.\n3. **Toast Notification**: Integrate a floating 'Undo' toast using the Deep Space design system (Task 35). The toast should display a countdown (e.g., 5 seconds) and an 'Undo' button.\n4. **Queue Logic**: \n   - If 'Undo' is clicked: Pop the action from the queue and restore the card to the UI stack.\n   - If timeout expires or queue length > 5: Trigger `flushQueue()`.\n   - On Page Unmount: Force `flushQueue()`.\n5. **Persistence**: Implement the `flushQueue` function to send buffered actions to the backend. Ideally, refactor the backend to accept a bulk status update endpoint to reduce network overhead.",
        "testStrategy": "1. **Optimistic Removal**: Swipe a job card and verify it disappears instantly while the Network tab shows no immediate request.\n2. **Undo Functionality**: Swipe a card, click 'Undo' on the toast, and verify the card reappears at the top of the stack.\n3. **Auto-Flush**: Swipe 3 cards rapidly, wait for the toast timeout, and verify that the backend receives the update requests (either as a batch or sequential calls).\n4. **Navigation Safety**: Swipe a card and immediately navigate to a different route; verify the action is flushed/persisted before the component unmounts.",
        "status": "done",
        "dependencies": [
          "35",
          "41"
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Bulk Job Status Update Endpoint",
            "description": "Develop a backend API endpoint to accept and process multiple job status updates in a single transaction to support queue flushing.",
            "dependencies": [],
            "details": "Implement `POST /api/jobs/bulk-status`. The payload should accept an array of objects: `{ updates: [{ jobId: string, status: 'TRASH' | 'WORKSPACE' }] }`. Ensure database updates are wrapped in a transaction to maintain data integrity. Add validation to ensure only valid status transitions are allowed.",
            "status": "done",
            "testStrategy": "Send a POST request with 5 job updates. Verify all 5 records are updated in the database. Send a request with mixed valid/invalid IDs and verify the transaction rolls back or handles errors gracefully.",
            "updatedAt": "2025-12-21T16:36:04.579Z",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement Triage Queue State Store",
            "description": "Create a client-side state management store (Zustand) to handle the temporary queue of pending triage actions.",
            "dependencies": [],
            "details": "Define `useTriageQueueStore`. State should include `queue: PendingAction[]` where `PendingAction` is `{ jobId, action, originalJobData, timestamp }`. Implement actions: `enqueueAction`, `undoAction` (remove specific ID), and `clearQueue`. Ensure the store persists in memory during the session.",
            "status": "done",
            "testStrategy": "Unit test the store: Call `enqueueAction` and verify queue length increases. Call `undoAction` and verify the specific item is removed. Call `clearQueue` and verify length is 0.",
            "parentId": "undefined",
            "updatedAt": "2025-12-21T16:37:24.348Z"
          },
          {
            "id": 3,
            "title": "Integrate Optimistic UI Updates in Triage Feed",
            "description": "Modify the main Triage Feed component to interact with the queue store, removing items visually immediately upon interaction.",
            "dependencies": [
              2
            ],
            "details": "Refactor the Triage Card swipe/button handlers. Instead of calling the API directly, call `enqueueAction`. Modify the rendered job list to filter out any `jobId` currently existing in the `queue` array, creating an instant 'removal' effect for the user.",
            "status": "done",
            "testStrategy": "Load the feed. Swipe a card. Verify the card disappears instantly from the UI. Check the Network tab to ensure no API call was made immediately upon the swipe.",
            "parentId": "undefined",
            "updatedAt": "2025-12-21T16:37:26.630Z"
          },
          {
            "id": 4,
            "title": "Develop Undo Toast Notification Component",
            "description": "Create a floating toast notification that appears when an action is queued, providing the user a mechanism to revert the action.",
            "dependencies": [
              2
            ],
            "details": "Using the Deep Space design system, build a toast that subscribes to the `queue` state. Display 'Moved to [Status]'. Include a countdown timer (visual progress bar) and an 'Undo' button. Clicking 'Undo' must trigger `undoAction` in the store, causing the card to reappear in the feed.",
            "status": "done",
            "testStrategy": "Swipe a card. Verify toast appears. Click 'Undo' before the timer expires. Verify the toast closes and the card reappears at the top of the stack.",
            "parentId": "undefined",
            "updatedAt": "2025-12-21T16:38:24.062Z"
          },
          {
            "id": 5,
            "title": "Implement Queue Flush Logic and Persistence",
            "description": "Develop the logic to automatically send buffered actions to the backend based on time, queue size, or component unmounting.",
            "dependencies": [
              1,
              2
            ],
            "details": "Implement a `flushQueue` function that consumes the queue and calls the bulk endpoint from Subtask 1. Set up listeners: 1. `setTimeout` for 5 seconds after the last action (debounce). 2. Trigger immediately if queue length > 5. 3. Use `useEffect` cleanup to flush on page unmount.",
            "status": "done",
            "testStrategy": "Swipe 3 cards and wait 5 seconds; verify 1 bulk API call is made. Swipe 6 cards rapidly; verify flush triggers immediately on the 6th. Navigate away from the page; verify flush triggers on unmount.",
            "parentId": "undefined",
            "updatedAt": "2025-12-21T16:38:26.283Z"
          }
        ],
        "updatedAt": "2025-12-21T16:38:26.283Z"
      },
      {
        "id": "45",
        "title": "Implement 'Chronos' Ingress Simulator & Settings",
        "description": "Develop a background simulation engine to inject synthetic job data into the system and a settings UI to control injection frequency and quality.",
        "details": "1. **Template Library**: Create a `jobTemplates.ts` module containing 100+ mock job definitions categorized by tier: 'Elite' (FAANG-style, high comp), 'Mediocre' (Standard agency work), and 'Garbage' (Irrelevant, typo-ridden, or MLM schemes). \n2. **Chronos Service**: Implement a background worker using the `node-cron` infrastructure established in Task 42. The service should randomly select templates based on the configured 'Chaos Level' and insert them into the database, adhering to the normalization rules from Task 38.\n3. **Configuration UI**: Add a 'Simulation' panel to the Settings page using the Deep Space design system (Task 35). Include a Master Toggle (On/Off), a Frequency Slider (1-50 jobs/hour), and a Chaos Level selector (Low/Medium/High).\n4. **State Persistence**: Store simulation config in a lightweight `SystemSettings` table or Redis to persist preferences across server restarts.",
        "testStrategy": "1. **Volume Test**: Set frequency to max (50/hr), run for 10 minutes, and verify ~8-9 new records appear in the database.\n2. **Distribution Test**: Set Chaos Level to 'High' and verify a higher percentage of 'Garbage' tier jobs are generated compared to 'Low'.\n3. **Control Test**: Toggle simulation 'Off' and ensure zero new jobs are created over a 1-hour period.\n4. **UI Integration**: Verify the Settings toggle correctly updates the backend state via the network tab.",
        "status": "done",
        "dependencies": [
          "35",
          "37",
          "38",
          "42"
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Job Template Library",
            "description": "Develop the static data module containing categorized mock job definitions for the simulation engine.",
            "dependencies": [],
            "details": "Create `src/lib/chronos/jobTemplates.ts`. Define interfaces for Job Templates. Populate three arrays: 'Elite' (high salary, tech giants), 'Mediocre' (average agency work), and 'Garbage' (MLM, typos). Ensure at least 100 total distinct templates with varied metadata.",
            "status": "done",
            "testStrategy": "Unit test the template selector to ensure it returns valid objects and that all required fields (title, company, salary range) are present in every template.",
            "updatedAt": "2025-12-21T16:20:44.593Z",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement Settings Persistence & API",
            "description": "Build the backend infrastructure to store and retrieve simulation configuration settings.",
            "dependencies": [],
            "details": "Create a `SystemSettings` table or Redis hash to store keys: `chronos_enabled` (bool), `chronos_frequency` (int), and `chronos_chaos_level` (enum). Implement API endpoints `GET /api/admin/chronos` and `PUT /api/admin/chronos` with validation logic.",
            "status": "done",
            "testStrategy": "Integration tests using Jest/Supertest to verify that settings can be saved, retrieved, and that invalid values (e.g., frequency > 50) are rejected.",
            "parentId": "undefined",
            "updatedAt": "2025-12-21T16:20:46.716Z"
          },
          {
            "id": 3,
            "title": "Develop Chronos Background Service",
            "description": "Implement the core logic engine that generates and inserts jobs based on time intervals and configuration.",
            "dependencies": [
              1,
              2
            ],
            "details": "Initialize a `node-cron` task. Logic: 1. Fetch current settings. 2. If enabled, calculate probability based on frequency. 3. Select template tier based on Chaos Level (e.g., High Chaos = 60% Garbage). 4. Hydrate template with timestamps. 5. Insert into DB using the Job Service.",
            "status": "done",
            "testStrategy": "Volume Test: Enable service with max frequency, run for 1 minute, and assert that the expected number of records were created in the database.",
            "parentId": "undefined",
            "updatedAt": "2025-12-21T16:20:48.952Z"
          },
          {
            "id": 4,
            "title": "Build Simulation Settings UI Panel",
            "description": "Create the frontend interface components for controlling the simulator within the Settings page.",
            "dependencies": [],
            "details": "Develop `SimulationPanel.tsx` using Deep Space design system. Implement a Master Toggle switch, a Range Slider for frequency (1-50 jobs/hr), and a Segmented Control for Chaos Level (Low/Medium/High). Ensure responsive layout.",
            "status": "done",
            "testStrategy": "Component testing (Storybook or React Testing Library) to verify that UI controls render correctly and emit the expected values on interaction.",
            "parentId": "undefined",
            "updatedAt": "2025-12-21T16:20:51.113Z"
          },
          {
            "id": 5,
            "title": "Integrate Settings UI with Chronos Service",
            "description": "Connect the frontend UI to the backend API and verify end-to-end control of the simulation.",
            "dependencies": [
              3,
              4
            ],
            "details": "Wire the `SimulationPanel` to the `useSystemSettings` hook. Implement debouncing for the frequency slider to prevent API spam. Add visual feedback (loading states/toasts) on save. Verify that toggling 'Off' in the UI immediately stops the background worker.",
            "status": "done",
            "testStrategy": "End-to-End Test: Open settings, change Chaos Level to 'High', wait 5 minutes, and verify via SQL query that the distribution of new jobs matches the 'High' profile.",
            "parentId": "undefined",
            "updatedAt": "2025-12-21T16:20:53.287Z"
          }
        ],
        "updatedAt": "2025-12-21T16:34:35.081Z"
      },
      {
        "id": "46",
        "title": "Refactor Pipeline UI to Neutral Dark Theme",
        "description": "Modernize the Kanban board with the new 'Deep Space' / Neutral Dark aesthetic.",
        "details": "Remove legacy column borders and backgrounds. Use the improved JobCard component or a specialized KanbanCard. Ensure drag-and-drop visuals match the new theme (no blue tints).",
        "priority": "high",
        "status": "in-progress",
        "dependencies": [
          "35",
          "43"
        ],
        "subtasks": [
          {
            "id": 1,
            "title": "Refactor Pipeline Board Layout",
            "description": "Remove column backgrounds and borders.",
            "status": "pending",
            "dependencies": [],
            "parentId": "46"
          },
          {
            "id": 2,
            "title": "Update Kanban Card Style",
            "description": "Ensure cards match the JobCard style.",
            "status": "pending",
            "dependencies": [],
            "parentId": "46"
          }
        ],
        "updatedAt": "2025-12-21T17:50:00.000Z"
      },
      {
        "id": "46",
        "title": "Refactor Pipeline UI to Neutral Dark Theme",
        "description": "Modernize the Kanban board with the new 'Deep Space' / Neutral Dark aesthetic.",
        "details": "Remove legacy column borders and backgrounds. Use the improved JobCard component or a specialized KanbanCard. Ensure drag-and-drop visuals match the new theme (no blue tints).",
        "priority": "high",
        "status": "done",
        "dependencies": [
          "35",
          "43"
        ],
        "subtasks": [
          {
            "id": 1,
            "title": "Refactor Pipeline Board Layout",
            "description": "Remove column backgrounds and borders.",
            "status": "pending",
            "dependencies": []
          },
          {
            "id": 2,
            "title": "Update Kanban Card Style",
            "description": "Ensure cards match the JobCard style.",
            "status": "pending",
            "dependencies": []
          }
        ],
        "updatedAt": "2025-12-21T18:00:00.000Z"
      },
      {
        "id": "47",
        "title": "Refactor Resume UI to Neutral Dark Theme",
        "description": "Clean up Resume Builder interface.",
        "details": "Update ResumeBuilder, AISettingsRail, and layout to use bg-card and remove heavy borders.",
        "priority": "high",
        "status": "done",
        "dependencies": [
          "46"
        ],
        "subtasks": [],
        "updatedAt": "2025-12-21T18:30:00.000Z"
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2025-12-22T00:49:44.968Z",
      "taskCount": 12,
      "completedCount": 11,
      "tags": [
        "tdd"
      ]
    }
  }
}