{
  "tdd": {
    "tasks": [
      {
        "id": "11",
        "title": "Initialize Next.js 14 Project with Core Dependencies and Docker Configuration",
        "description": "Set up the foundational Next.js 14 project structure with TypeScript, configure Docker Compose stack (app, PostgreSQL 15, n8n, nginx, Redis), and establish the development environment with all required dependencies.",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "details": "1. Initialize Next.js 14 project with App Router and TypeScript:\n   ```bash\n   npx create-next-app@latest job-search-platform --typescript --tailwind --app --src-dir\n   ```\n\n2. Install core dependencies:\n   ```bash\n   npm install @prisma/client prisma zod react-hook-form @hookform/resolvers\n   npm install @langchain/openai @langchain/anthropic langchain\n   npm install mapbox-gl react-map-gl @dnd-kit/core @dnd-kit/sortable\n   npm install @radix-ui/react-* (shadcn/ui components)\n   npm install next-auth bcrypt jsonwebtoken\n   npm install framer-motion recharts\n   npm install -D @types/node @types/react @types/mapbox-gl\n   ```\n\n3. Create Docker Compose configuration (docker-compose.yml):\n   ```yaml\n   version: '3.8'\n   services:\n     app:\n       build: .\n       ports:\n         - '3000:3000'\n       environment:\n         - DATABASE_URL=postgresql://user:pass@db:5432/jobsearch\n       depends_on:\n         - db\n         - redis\n     db:\n       image: postgres:15-alpine\n       environment:\n         POSTGRES_USER: user\n         POSTGRES_PASSWORD: pass\n         POSTGRES_DB: jobsearch\n       volumes:\n         - postgres_data:/var/lib/postgresql/data\n     n8n:\n       image: n8nio/n8n\n       ports:\n         - '5678:5678'\n       environment:\n         - N8N_BASIC_AUTH_ACTIVE=true\n       volumes:\n         - n8n_data:/home/node/.n8n\n     redis:\n       image: redis:7-alpine\n       ports:\n         - '6379:6379'\n     nginx:\n       image: nginx:alpine\n       ports:\n         - '80:80'\n         - '443:443'\n       volumes:\n         - ./nginx.conf:/etc/nginx/nginx.conf\n   volumes:\n     postgres_data:\n     n8n_data:\n   ```\n\n4. Create multi-stage Dockerfile for Next.js app\n5. Set up .env.example with all required environment variables\n6. Configure tsconfig.json with path aliases (@/ for src/)\n7. Initialize Git repository with .gitignore",
        "testStrategy": "1. Verify Docker Compose stack starts successfully: `docker-compose up -d`\n2. Confirm all services are healthy: `docker-compose ps`\n3. Test Next.js dev server runs: `npm run dev` accessible at localhost:3000\n4. Verify PostgreSQL connection: `docker exec -it <db-container> psql -U user -d jobsearch`\n5. Check n8n interface loads at localhost:5678\n6. Validate TypeScript compilation: `npm run build`\n7. Ensure all dependencies install without conflicts",
        "subtasks": [
          {
            "id": 1,
            "title": "Initialize Next.js 14 project with App Router and TypeScript",
            "description": "Set up the foundational Next.js 14 project structure using create-next-app CLI with App Router and TypeScript",
            "dependencies": [],
            "details": "Execute npx create-next-app@latest job-search-platform --typescript --tailwind --app --src-dir to create project structure with TypeScript, Tailwind CSS, App Router, and src directory organization. Verify proper file structure including app/layout.tsx and page.tsx\n<info added on 2025-11-19T11:43:01.958Z>\nPlan:\n1. Create a verification script tests/verify_project_structure.js to check for the existence of job-search-platform and key files (package.json, tsconfig.json, src/app).\n2. Run the verification script (expect failure).\n3. Execute npx create-next-app@latest job-search-platform --typescript --tailwind --app --src-dir --no-eslint --no-import-alias.\n4. Verify the installation.\n5. Run the verification script (expect success).\n</info added on 2025-11-19T11:43:01.958Z>",
            "status": "done",
            "testStrategy": "Confirm project structure contains app/ directory, tsconfig.json, and src/ directory; verify Next.js dev server runs with npm run dev and accessible at localhost:3000",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Install and organize core dependencies for job search platform",
            "description": "Install all required npm packages including Prisma, LangChain, UI components, and authentication libraries",
            "dependencies": [
              1
            ],
            "details": "Execute npm install commands for @prisma/client, zod, react-hook-form, LangChain packages, mapbox-gl, shadcn/ui components, next-auth, and development dependencies; verify package.json contains all required dependencies with proper version ranges\n<info added on 2025-11-19T17:04:49.945Z>\nPlan:\n1. Create `tests/verify_dependencies.js` to check `job-search-platform/package.json` for required dependencies.\n2. Run verification (expect failure).\n3. Install dependencies:\n   - Core: `npm install @prisma/client zod react-hook-form @hookform/resolvers next-auth bcrypt jsonwebtoken framer-motion recharts`\n   - AI: `npm install @langchain/openai @langchain/anthropic langchain`\n   - Maps/UI: `npm install mapbox-gl react-map-gl @dnd-kit/core @dnd-kit/sortable`\n   - Dev: `npm install -D prisma @types/mapbox-gl @types/bcrypt @types/jsonwebtoken`\n4. Run verification (expect success).\n</info added on 2025-11-19T17:04:49.945Z>",
            "status": "done",
            "testStrategy": "Check package.json for all required dependencies; verify no dependency conflicts; test basic imports in a sample component; confirm TypeScript definitions are properly installed",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Configure Docker Compose stack with all required services",
            "description": "Set up docker-compose.yml with Next.js app, PostgreSQL 15, n8n, Redis, and nginx services with proper networking",
            "dependencies": [
              1,
              2
            ],
            "details": "Create docker-compose.yml with services for app, db (PostgreSQL 15), n8n, redis, and nginx; configure proper ports, environment variables, volumes, and service dependencies; ensure networking between containers is correctly configured with appropriate health checks\n<info added on 2025-11-19T17:06:35.598Z>\nPlan:\n1. Create tests/verify_docker_compose.js to validate docker-compose.yml exists and contains required services (app, db, n8n, redis, nginx).\n2. Run verification (expect failure).\n3. Create job-search-platform/docker-compose.yml with defined services and configuration.\n4. Create job-search-platform/nginx.conf for the nginx service.\n5. Run verification (expect success).\n</info added on 2025-11-19T17:06:35.598Z>",
            "status": "done",
            "testStrategy": "Run docker-compose up -d and verify all services start successfully; check docker-compose ps for healthy status; test connectivity between services using docker network inspect",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Create optimized multi-stage Dockerfile for Next.js application",
            "description": "Implement efficient Docker build process with separate build and runtime stages to minimize image size",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Create Dockerfile with builder stage (Node.js with dependencies) and runtime stage (minimal production build); copy only necessary files between stages; optimize layer caching; configure proper working directory and command execution for both development and production environments\n<info added on 2025-11-19T17:07:38.896Z>\nPlan:\n1. Create `tests/verify_dockerfile.js` to validate `Dockerfile` exists and uses multi-stage build (checks for 'FROM ... AS builder' and 'FROM ... AS runner').\n2. Run verification (expect failure).\n3. Create `job-search-platform/Dockerfile` with optimized multi-stage build for Next.js.\n4. Run verification (expect success).\n</info added on 2025-11-19T17:07:38.896Z>",
            "status": "done",
            "testStrategy": "Build Docker image and verify size is minimized; test application runs correctly in container; confirm only necessary files are included in final image; validate build process completes without errors",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement environment variable management with .env files",
            "description": "Create comprehensive environment variable system with .env.example and validation",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Create .env.example with all required environment variables (DATABASE_URL, API keys, etc.); implement validation mechanism using Zod; configure Next.js to properly load environment variables in development and production; document all required variables with examples and security considerations\n<info added on 2025-11-19T17:08:40.214Z>\nPlan:\n1. Create `tests/verify_env.js` to validate `.env.example` exists and `src/env.ts` (validation logic) exists.\n2. Run verification (expect failure).\n3. Create `job-search-platform/.env.example` with keys: DATABASE_URL, GOOGLE_CLIENT_ID, GOOGLE_CLIENT_SECRET, NEXTAUTH_SECRET, NEXTAUTH_URL, NEXT_PUBLIC_MAPBOX_TOKEN, OPENAI_API_KEY, ANTHROPIC_API_KEY.\n4. Create `job-search-platform/src/env.ts` using Zod for validation.\n5. Run verification (expect success).\n</info added on 2025-11-19T17:08:40.214Z>",
            "status": "done",
            "testStrategy": "Verify all required environment variables are documented in .env.example; test application fails gracefully with missing variables; confirm variables are properly loaded in different environments using runtime checks",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Configure TypeScript with path aliases and typed routes",
            "description": "Set up advanced TypeScript configuration including path aliases and typed route validation",
            "dependencies": [
              1,
              2,
              5
            ],
            "details": "Configure tsconfig.json with path aliases (@/ for src/); enable typedRoutes in next.config.js; set up proper module resolution; configure TypeScript for Next.js App Router; validate TypeScript configuration with sample components using Route type from next package\n<info added on 2025-11-19T17:09:38.512Z>\nPlan:\n1. Create `tests/verify_tsconfig.js` to validate:\n   - `tsconfig.json` has `compilerOptions.paths` containing `\"@/*\": [\"./src/*\"]`.\n   - `next.config.ts` has `experimental: { typedRoutes: true }`.\n2. Run verification (expect failure on typedRoutes).\n3. Modify `job-search-platform/next.config.ts` to add `typedRoutes: true`.\n4. Run verification (expect success).\n</info added on 2025-11-19T17:09:38.512Z>",
            "status": "done",
            "testStrategy": "Verify path aliases work correctly in imports; test typed route validation with invalid route to confirm TypeScript errors; check build process completes without TypeScript errors; validate route types in Link components",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": "12",
        "title": "Design and Implement Prisma Database Schema with Migrations",
        "description": "Create the complete Prisma schema matching the PRD specifications (User, Profile, Job, Application, Config models) and set up initial database migrations with proper indexes and relationships.",
        "status": "done",
        "dependencies": [
          "11"
        ],
        "priority": "high",
        "details": "1. Initialize Prisma:\n   ```bash\n   npx prisma init\n   ```\n\n2. Create schema.prisma with exact models from PRD:\n   ```prisma\n   generator client {\n     provider = \"prisma-client-js\"\n   }\n\n   datasource db {\n     provider = \"postgresql\"\n     url      = env(\"DATABASE_URL\")\n   }\n\n   model User {\n     id            String        @id @default(cuid())\n     email         String        @unique\n     name          String?\n     createdAt     DateTime      @default(now())\n     updatedAt     DateTime      @updatedAt\n     profile       Profile?\n     applications  Application[]\n     config        Config?\n     @@index([email])\n   }\n\n   model Profile {\n     id              String   @id @default(cuid())\n     userId          String   @unique\n     user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)\n     contactInfo     Json\n     workHistory     Json[]\n     education       Json[]\n     skills          String[]\n     projects        Json[]\n     certifications  Json[]\n     preferences     Json\n     completeness    Int      @default(0)\n     createdAt       DateTime @default(now())\n     updatedAt       DateTime @updatedAt\n   }\n\n   model Job {\n     id              String        @id @default(cuid())\n     title           String\n     company         String\n     location        String\n     latitude        Float?\n     longitude       Float?\n     description     String        @db.Text\n     salary          String?\n     postedAt        DateTime\n     source          String\n     sourceUrl       String\n     cityMatch       String?\n     distanceMiles   Float?\n     compositeScore  Float?\n     createdAt       DateTime      @default(now())\n     applications    Application[]\n     @@index([postedAt, source])\n     @@index([cityMatch, compositeScore])\n   }\n\n   model Application {\n     id            String    @id @default(cuid())\n     userId        String\n     user          User      @relation(fields: [userId], references: [id], onDelete: Cascade)\n     jobId         String\n     job           Job       @relation(fields: [jobId], references: [id], onDelete: Cascade)\n     status        String    @default(\"discovered\")\n     resumePath    String?\n     notes         String?   @db.Text\n     createdAt     DateTime  @default(now())\n     updatedAt     DateTime  @updatedAt\n     appliedAt     DateTime?\n     statusHistory Json[]\n     @@index([userId, status])\n     @@index([jobId])\n   }\n\n   model Config {\n     id            String   @id @default(cuid())\n     userId        String   @unique\n     user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)\n     searchParams  Json\n     llmConfig     Json\n     dailyCaps     Json\n     fileNaming    String   @default(\"YYYY-MM-DD - {company} - {role}.pdf\")\n     version       String   @default(\"1.0\")\n     createdAt     DateTime @default(now())\n     updatedAt     DateTime @updatedAt\n   }\n   ```\n\n3. Generate and run migrations:\n   ```bash\n   npx prisma migrate dev --name init\n   npx prisma generate\n   ```\n\n4. Create seed script (prisma/seed.ts) for development data\n5. Set up Prisma Client singleton pattern in src/lib/prisma.ts",
        "testStrategy": "1. Run migration successfully: `npx prisma migrate dev`\n2. Verify all tables created in PostgreSQL: `npx prisma studio`\n3. Test CRUD operations for each model using Prisma Client\n4. Validate relationships work (cascade deletes, foreign keys)\n5. Check indexes are created: Query PostgreSQL system tables\n6. Run seed script and verify data: `npx prisma db seed`\n7. Test schema validation with invalid data (should fail gracefully)",
        "subtasks": [
          {
            "id": 1,
            "title": "Design Prisma Schema with Complete Model Relationships",
            "description": "Implement the complete Prisma schema with all required models and properly configured relationships including cascade deletes",
            "dependencies": [],
            "details": "Create schema.prisma file with User, Profile, Job, Application, and Config models from PRD specifications. Configure all relationships with proper onDelete actions (Cascade, SetNull). Ensure required fields, constraints, and data types match requirements. Pay special attention to one-to-one (User-Profile, User-Config) and one-to-many (User-Application, Job-Application) relationships. Validate JSON field usage for complex data structures.\n<info added on 2025-11-19T17:32:45.871Z>\nPlan:\n1. Initialize Prisma in the project: cd job-search-platform && npx prisma init\n2. Create tests/verify_prisma_schema.js to parse job-search-platform/prisma/schema.prisma and verify:\n    - Models: User, Profile, Job, Application, Config exist.\n    - User model has email, profile, applications, config.\n    - Profile model has userId relation.\n    - Job model has applications.\n    - Application model has userId, jobId.\n    - Config model has userId, searchParams.\n3. Run verification (expect failure).\n4. Update job-search-platform/prisma/schema.prisma with the complete schema definition from the task details.\n5. Run verification (expect success).\n</info added on 2025-11-19T17:32:45.871Z>",
            "status": "done",
            "testStrategy": "Verify relationships work through Prisma Studio. Test cascade operations manually. Check foreign key constraints in database. Validate schema against PRD requirements.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement Strategic Indexing for Query Performance",
            "description": "Analyze query patterns and implement optimized indexing strategy across all database models",
            "dependencies": [
              1
            ],
            "details": "Review expected query patterns from application requirements. Add indexes for foreign keys, unique fields, and frequently queried columns. Implement composite indexes where needed (e.g., [userId, status] for Application model, [postedAt, source] for Job model). Validate index strategy against expected query patterns. Document rationale for each index. Ensure all specified indexes from PRD are correctly implemented.\n<info added on 2025-11-19T17:40:22.213Z>\nPlan:\n1. Create `tests/verify_indexes.js` to parse `job-search-platform/prisma/schema.prisma` and verify specific indexes:\n    - User: `@@index([email])`\n    - Job: `@@index([postedAt, source])`, `@@index([cityMatch, compositeScore])`\n    - Application: `@@index([userId, status])`, `@@index([jobId])`\n2. Run verification (expect success, as indexes were added in previous step).\n3. If success, we will double-check if any additional indexes from the plan are missing.\n4. Run verification (expect success).\n</info added on 2025-11-19T17:40:22.213Z>",
            "status": "done",
            "testStrategy": "Use database EXPLAIN ANALYZE to verify index usage. Test query performance before and after index implementation. Validate that all specified indexes are correctly created in PostgreSQL. Check index coverage for critical queries.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Configure Prisma Migration Workflow with Seed Data",
            "description": "Set up complete Prisma migration process including initial migration, seed script, and validation procedures",
            "dependencies": [
              1,
              2
            ],
            "details": "Create initial migration using 'prisma migrate dev --name init'. Implement seed script (prisma/seed.ts) with realistic development data for all models. Configure migration workflow according to best practices (using prisma db push vs prisma migrate). Set up proper environment variables and connection pooling configuration. Include validation steps to ensure migrations apply correctly across environments.\n<info added on 2025-11-19T17:41:35.029Z>\nPlan:\n1. Create tests/verify_seed.js to check for existence of job-search-platform/prisma/seed.ts and verify it contains seeding logic for at least one user/job.\n2. Run verification (expect failure).\n3. Create job-search-platform/prisma/seed.ts with realistic mock data for users, jobs, and config.\n4. Configure package.json to add prisma seed command.\n5. Run verification (expect success).\n</info added on 2025-11-19T17:41:35.029Z>",
            "status": "done",
            "testStrategy": "Run migration successfully and verify all tables created. Test seed script execution with sample data. Validate data integrity after seeding. Check migration history is properly tracked. Test rollback procedures in development environment.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement Prisma Client Singleton Pattern with Connection Management",
            "description": "Set up Prisma Client with proper singleton pattern and connection management for production use",
            "dependencies": [
              3
            ],
            "details": "Create Prisma Client singleton in src/lib/prisma.ts to prevent multiple instances in development. Configure connection pool settings appropriate for production environment (max connections, timeout). Implement proper error handling and logging. Set up query logging configuration for different environments (development vs production). Include SSL configuration for secure database connections.\n<info added on 2025-11-19T17:45:20.431Z>\nPlan:\n1. Create tests/verify_prisma_client.js to check for job-search-platform/src/lib/prisma.ts.\n2. Run verification (expect failure).\n3. Create job-search-platform/src/lib/prisma.ts implementing the singleton pattern for Prisma Client.\n4. Run verification (expect success).\n</info added on 2025-11-19T17:45:20.431Z>",
            "status": "done",
            "testStrategy": "Verify only one Prisma Client instance is created. Test database connection under load. Validate connection pool settings are applied. Check error handling works as expected. Test SSL connection in production-like environment.",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": "13",
        "title": "Implement Authentication System with NextAuth and Single-User Mode",
        "description": "Set up NextAuth with Google OAuth provider, email/password fallback using bcrypt, JWT session management, and implement single-user mode bypass option as specified in the PRD.",
        "status": "done",
        "dependencies": [
          "12"
        ],
        "priority": "high",
        "details": "1. Install NextAuth dependencies:\n   ```bash\n   npm install next-auth @next-auth/prisma-adapter\n   npm install bcryptjs @types/bcryptjs\n   ```\n\n2. Create NextAuth configuration (src/app/api/auth/[...nextauth]/route.ts):\n   ```typescript\n   import NextAuth from 'next-auth';\n   import GoogleProvider from 'next-auth/providers/google';\n   import CredentialsProvider from 'next-auth/providers/credentials';\n   import { PrismaAdapter } from '@next-auth/prisma-adapter';\n   import { prisma } from '@/lib/prisma';\n   import bcrypt from 'bcryptjs';\n\n   export const authOptions = {\n     adapter: PrismaAdapter(prisma),\n     providers: [\n       GoogleProvider({\n         clientId: process.env.GOOGLE_CLIENT_ID!,\n         clientSecret: process.env.GOOGLE_CLIENT_SECRET!,\n       }),\n       CredentialsProvider({\n         name: 'Credentials',\n         credentials: {\n           email: { label: 'Email', type: 'email' },\n           password: { label: 'Password', type: 'password' }\n         },\n         async authorize(credentials) {\n           if (!credentials?.email || !credentials?.password) return null;\n           const user = await prisma.user.findUnique({\n             where: { email: credentials.email }\n           });\n           if (!user || !user.password) return null;\n           const isValid = await bcrypt.compare(credentials.password, user.password);\n           return isValid ? user : null;\n         }\n       })\n     ],\n     session: {\n       strategy: 'jwt',\n       maxAge: 30 * 24 * 60 * 60, // 30 days\n     },\n     pages: {\n       signIn: '/auth/signin',\n     },\n     callbacks: {\n       async jwt({ token, user }) {\n         if (user) token.id = user.id;\n         return token;\n       },\n       async session({ session, token }) {\n         if (session.user) session.user.id = token.id;\n         return session;\n       }\n     }\n   };\n   ```\n\n3. Create single-user mode middleware (src/middleware.ts):\n   ```typescript\n   import { NextResponse } from 'next/server';\n   import type { NextRequest } from 'next/server';\n\n   export function middleware(request: NextRequest) {\n     if (process.env.SINGLE_USER_MODE === 'true') {\n       // Bypass auth, inject default user\n       return NextResponse.next();\n     }\n     // Normal auth flow\n   }\n   ```\n\n4. Implement rate limiting with Redis for login attempts\n5. Create auth UI components (SignIn, SignUp pages)\n6. Add CSRF protection middleware\n7. Set up password hashing utilities",
        "testStrategy": "1. Test Google OAuth flow in development\n2. Verify email/password registration and login\n3. Confirm JWT tokens are generated and validated\n4. Test session persistence across page reloads\n5. Validate rate limiting (5 attempts per 15 min)\n6. Test single-user mode bypasses auth correctly\n7. Verify CSRF protection blocks invalid requests\n8. Test password hashing (bcrypt rounds = 10)\n9. Confirm 30-day session expiration works",
        "subtasks": [
          {
            "id": 1,
            "title": "Configure NextAuth with Google OAuth and Credentials Provider",
            "description": "Set up NextAuth core configuration with Google OAuth integration and email/password authentication fallback",
            "dependencies": [],
            "details": "Install next-auth and required dependencies. Create [...nextauth]/route.ts file with GoogleProvider and CredentialsProvider. Configure environment variables for Google client ID/secret. Implement bcrypt password verification in authorize callback. Set up Prisma adapter for database connection.",
            "status": "done",
            "testStrategy": "Verify Google login redirects to authorization page. Test valid/invalid credentials login flow. Confirm user records created in database.",
            "parentId": "undefined",
            "updatedAt": "2025-11-19T21:16:34.834Z"
          },
          {
            "id": 2,
            "title": "Implement Security Features (JWT, CSRF, Rate Limiting)",
            "description": "Add security layers including JWT token management, CSRF protection, and Redis-based rate limiting for authentication endpoints",
            "dependencies": [
              1
            ],
            "details": "Configure JWT session strategy with proper expiration. Implement CSRF token generation/validation middleware. Set up Redis client for rate limiting. Create login attempt tracking with 5 attempts per 15 minutes limit. Add secure cookie settings and HTTPS enforcement in production.",
            "status": "done",
            "testStrategy": "Test JWT token generation/verification. Validate CSRF protection blocks unauthorized requests. Verify rate limiting triggers after 5 failed attempts. Check secure cookie attributes in browser.",
            "parentId": "undefined",
            "updatedAt": "2025-11-19T21:18:30.909Z"
          },
          {
            "id": 3,
            "title": "Develop Single-User Mode Bypass Logic",
            "description": "Implement and isolate single-user authentication bypass mechanism for development and special access scenarios",
            "dependencies": [
              1
            ],
            "details": "Create middleware to detect SINGLE_USER_MODE environment variable. Implement secure user injection without authentication flow. Add safeguards to prevent accidental production deployment. Configure default user credentials securely. Ensure bypass logic is completely disabled in production environments.",
            "status": "done",
            "testStrategy": "Verify auth bypass works when SINGLE_USER_MODE=true. Confirm normal auth flow when mode is disabled. Test production build rejects bypass attempts. Validate security audit logs for bypass usage.",
            "parentId": "undefined",
            "updatedAt": "2025-11-19T21:20:33.355Z"
          },
          {
            "id": 4,
            "title": "Configure Session Management Strategy",
            "description": "Implement robust session handling with JWT token management, session persistence, and token refresh mechanisms",
            "dependencies": [
              1,
              2
            ],
            "details": "Set up JWT callbacks for token augmentation with user ID. Configure session callback to attach user data. Implement session expiration and renewal logic. Create token refresh endpoint. Add session invalidation on password change. Configure maxAge and updateAge parameters for security.",
            "status": "done",
            "testStrategy": "Test session persistence across page reloads. Verify token expiration after 30 days. Confirm session invalidation on password change. Validate token refresh functionality. Check session data consistency.",
            "parentId": "undefined",
            "updatedAt": "2025-11-19T21:22:47.731Z"
          },
          {
            "id": 5,
            "title": "Build Authentication UI Components",
            "description": "Create responsive sign-in, sign-up, and password management interfaces with proper error handling and user feedback",
            "dependencies": [
              1
            ],
            "details": "Develop /auth/signin page with Google and email/password options. Create registration form with validation. Implement password reset flow. Add error messaging for failed attempts. Design responsive layouts for all device sizes. Integrate with NextAuth client-side session management. Include loading states and accessibility features.",
            "status": "done",
            "testStrategy": "Test UI on mobile, tablet, and desktop views. Verify form validation rules. Confirm error messages display correctly. Check accessibility compliance. Validate successful login redirects. Test password visibility toggle functionality.",
            "parentId": "undefined",
            "updatedAt": "2025-11-19T21:26:36.748Z"
          }
        ],
        "updatedAt": "2025-11-19T21:26:36.748Z"
      },
      {
        "id": "14",
        "title": "Build Multi-Step Configuration Wizard with Form Validation",
        "description": "Create the 6-step onboarding wizard UI with React Hook Form and Zod validation, implementing all configuration steps (cities, job titles, keywords, salary, recency) with progress tracking, data persistence, and a dedicated /onboarding route verified by E2E tests.",
        "status": "done",
        "dependencies": [
          "13"
        ],
        "priority": "high",
        "details": "1. Create Zod schemas for each step:\n   ```typescript\n   // src/lib/validations/config.ts\n   import { z } from 'zod';\n\n   export const citySchema = z.object({\n     name: z.string().min(1, 'City name required'),\n     radius_miles: z.number().min(5).max(100),\n     weight: z.number().min(0).max(100)\n   });\n\n   export const step1Schema = z.object({\n     cities: z.array(citySchema).min(1, 'At least one city required')\n   });\n\n   export const step2Schema = z.object({\n     categories: z.array(z.string()).min(1, 'At least one job title required')\n   });\n\n   export const configSchema = z.object({\n     cities: z.array(citySchema),\n     categories: z.array(z.string()),\n     include_keywords: z.array(z.string()),\n     exclude_keywords: z.array(z.string()),\n     salary_usd: z.object({\n       min: z.number().optional(),\n       max: z.number().optional()\n     }),\n     posted_within_hours: z.number()\n   });\n   ```\n\n2. Build wizard component with shadcn/ui:\n   ```typescript\n   // src/components/onboarding/ConfigWizard.tsx\n   import { useState } from 'react';\n   import { useForm } from 'react-hook-form';\n   import { zodResolver } from '@hookform/resolvers/zod';\n\n   const steps = [\n     { id: 1, title: 'Target Cities', component: Step1Cities },\n     { id: 2, title: 'Job Titles', component: Step2Titles },\n     { id: 3, title: 'Include Keywords', component: Step3Include },\n     { id: 4, title: 'Exclude Keywords', component: Step4Exclude },\n     { id: 5, title: 'Salary Range', component: Step5Salary },\n     { id: 6, title: 'Job Freshness', component: Step6Recency }\n   ];\n   ```\n\n3. Implement auto-save every 30 seconds using useEffect\n4. Create progress indicator component (0-100%)\n5. Build each step component with appropriate inputs:\n   - Step 1: City autocomplete + radius slider + weight slider\n   - Step 2: Tag input for job titles\n   - Step 3: Keyword tag input with OR logic explanation\n   - Step 4: Exclusion keyword tag input\n   - Step 5: Min/max salary inputs with checkbox for undisclosed\n   - Step 6: Radio buttons for recency options\n6. Add navigation (Back/Next/Skip buttons)\n7. Implement data persistence to Config model\n8. Create JSON export/import functionality\n9. Create /onboarding route to host the wizard\n10. Wire up API integration for saving data to database\n11. Implement E2E tests using Playwright/Cypress",
        "testStrategy": "1. Test form validation for each step (invalid inputs rejected)\n2. Verify progress indicator updates correctly (0% â†’ 100%)\n3. Test auto-save functionality (check DB after 30s)\n4. Validate navigation (Back/Next/Skip work correctly)\n5. Test city autocomplete with real geocoding API\n6. Verify weight sliders sum to 100% validation\n7. Test JSON export/import round-trip\n8. Confirm data persists to Config table\n9. Test wizard completion creates valid config.json\n10. Verify tooltips and help text display correctly\n11. E2E: Verify full wizard flow loads at /onboarding\n12. E2E: Confirm data is saved to DB upon completion",
        "subtasks": [
          {
            "id": 1,
            "title": "Design and implement Zod validation schemas for all configuration steps",
            "description": "Create comprehensive validation schemas for each wizard step with proper error messages and interdependent validation rules",
            "dependencies": [],
            "details": "Implement citySchema with radius and weight constraints, step1Schema for cities array, step2Schema for job titles, and complete configSchema. Add custom validation for weight sliders summing to 100% and handle conditional validation for salary ranges.\n<info added on 2025-11-19T22:13:20.314Z>\nPlan:\n1. Create `job-search-platform/tests/unit/validations/config.test.ts`.\n2. Write unit tests using `zod` to verify:\n    - `citySchema` rejects empty names, invalid radius (<5), invalid weights (<0 or >100).\n    - `step1Schema` requires non-empty cities array.\n    - `step2Schema` requires non-empty categories array.\n    - `configSchema` validates the full object structure.\n3. Run `npm test` (expect failure as files don't exist).\n4. Create `job-search-platform/src/lib/validations/config.ts` with the Zod schemas.\n5. Run `npm test` (expect success).\n</info added on 2025-11-19T22:13:20.314Z>",
            "status": "done",
            "testStrategy": "Validate each schema with edge cases: empty cities array, invalid radius values, weight sums exceeding 100%, and salary range inconsistencies",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Build wizard state management architecture with React Hook Form",
            "description": "Implement the core wizard structure using React Hook Form with proper state management across navigation",
            "dependencies": [
              1
            ],
            "details": "Create ConfigWizard component with useForm and zodResolver. Implement step navigation logic with useWizard hook pattern. Manage form state persistence between steps and handle validation triggers during navigation. Integrate with shadcn/ui components for consistent styling.\n<info added on 2025-11-19T22:15:09.927Z>\nPlan:\n1. Create `job-search-platform/tests/unit/components/ConfigWizard.test.tsx`.\n2. Write test: Render `ConfigWizard` and check for \"Target Cities\" (Step 1) heading.\n3. Run `npm test` (Expect Fail).\n4. Create `job-search-platform/src/components/onboarding/ConfigWizard.tsx`.\n5. Implement the basic wizard shell (useForm, useState for steps).\n6. Run `npm test` (Expect Pass).\n</info added on 2025-11-19T22:15:09.927Z>",
            "status": "done",
            "testStrategy": "Test state preservation when navigating back/forward, verify validation triggers correctly, and confirm form values persist through step transitions",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Develop individual step components with specialized UI elements",
            "description": "Build all six configuration step components with appropriate inputs and validation feedback",
            "dependencies": [
              1,
              2
            ],
            "details": "Implement Step1Cities with Mapbox autocomplete and dual sliders, Step2Titles with tag input, Step3Include/Step4Exclude with keyword tag inputs, Step5Salary with min/max inputs and undisclosed checkbox, and Step6Recency with radio buttons. Ensure each component connects properly to form state.\n<info added on 2025-11-19T22:17:20.059Z>\nPlan:\n1. Create `job-search-platform/tests/unit/components/steps/Step1Cities.test.tsx`.\n2. Write test: Verify it renders a city input and radius slider.\n3. Run `npm test` (Expect Fail).\n4. Create `job-search-platform/src/components/onboarding/steps/Step1Cities.tsx`.\n5. Implement the component using `react-hook-form` context.\n6. Run `npm test` (Expect Pass).\n</info added on 2025-11-19T22:17:20.059Z>",
            "status": "done",
            "testStrategy": "Validate each component's UI elements function correctly, test validation error display, and verify proper data binding to form state for all input types",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement auto-save functionality with debounce mechanism",
            "description": "Create auto-save system that persists form data every 30 seconds with proper state management",
            "dependencies": [
              2,
              3
            ],
            "details": "Set up useEffect hook with 30-second debounce timer. Implement save handler that stores current form values in localStorage and syncs with backend API. Add visual feedback for save status. Handle edge cases like form submission during auto-save.\n<info added on 2025-11-19T22:19:50.895Z>\nPlan:\n1. Create `job-search-platform/tests/unit/hooks/useAutoSave.test.ts`.\n2. Write test: Verify hook calls save callback after 30 seconds of inactivity (debounce).\n3. Run `npm test` (Expect Fail).\n4. Create `job-search-platform/src/hooks/useAutoSave.ts`.\n5. Implement `useAutoSave` hook using `useEffect` and `setTimeout`.\n6. Run `npm test` (Expect Pass).\n</info added on 2025-11-19T22:19:50.895Z>",
            "status": "done",
            "testStrategy": "Verify data saves after 30s interval, test save status indicators, and confirm data persists through page refresh. Check localStorage entries and API calls during save operations",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Develop progress calculation and visualization system",
            "description": "Create progress indicator that accurately reflects completion percentage across all wizard steps",
            "dependencies": [
              2,
              3
            ],
            "details": "Implement calculateProgress function that evaluates required fields per step. Build ProgressIndicator component showing 0-100% with visual feedback. Integrate with wizard state to update in real-time as users complete steps. Add tooltips showing incomplete sections.\n<info added on 2025-11-19T22:21:04.668Z>\nPlan:\n1. Create `job-search-platform/tests/unit/components/ProgressBar.test.tsx`.\n2. Write test: Verify progress bar width is calculated correctly (e.g., Step 1/6 = ~16%).\n3. Run `npm test` (Expect Fail).\n4. Create `job-search-platform/src/components/ui/ProgressBar.tsx`.\n5. Implement component.\n6. Run `npm test` (Expect Pass).\n</info added on 2025-11-19T22:21:04.668Z>",
            "status": "done",
            "testStrategy": "Test progress calculation with partial/complete data, verify visual representation matches calculated percentage, and confirm updates during navigation and data entry",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Implement data persistence and JSON export/import functionality",
            "description": "Create mechanisms to persist configuration data to Config model and enable JSON export/import",
            "dependencies": [
              2,
              3,
              4,
              5
            ],
            "details": "Build service layer connecting form data to Prisma Config model. Implement exportConfig function generating JSON structure matching configSchema. Create importConfig function with validation. Add UI controls for export/import operations with error handling for invalid JSON.\n<info added on 2025-11-19T22:22:07.621Z>\nPlan:\n1. Create `job-search-platform/tests/unit/components/ConfigActions.test.tsx`.\n2. Write test: Verify Export button exists and triggers file download simulation. Verify Import button exists.\n3. Run `npm test` (Expect Fail).\n4. Create `job-search-platform/src/components/onboarding/ConfigActions.tsx`.\n5. Implement Export (JSON.stringify + Blob) and Import (FileReader) logic.\n6. Run `npm test` (Expect Pass).\n</info added on 2025-11-19T22:22:07.621Z>",
            "status": "done",
            "testStrategy": "Test round-trip JSON export/import, verify data integrity after import, and confirm proper validation of imported data against configSchema. Test edge cases with malformed JSON",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2025-12-05T20:14:42.681Z"
      },
      {
        "id": "15",
        "title": "Create Master Profile Builder with Rich Text Editor and Auto-Save",
        "description": "Implement the comprehensive profile management system with Tiptap rich text editor, multi-section form (contact, work history, education, skills, projects, certifications), progress tracking, and GPT-5.1 Vision OCR import from existing resumes. Includes integration of the /profile route, database persistence, and E2E testing.",
        "status": "done",
        "dependencies": [
          "13"
        ],
        "priority": "high",
        "details": "1. Install Tiptap dependencies:\n   ```bash\n   npm install @tiptap/react @tiptap/starter-kit @tiptap/extension-placeholder\n   ```\n\n2. Create Profile form structure:\n   ```typescript\n   // src/components/profile/ProfileBuilder.tsx\n   const sections = [\n     { id: 'contact', title: 'Contact Information', weight: 10 },\n     { id: 'work', title: 'Work History', weight: 40 },\n     { id: 'education', title: 'Education', weight: 15 },\n     { id: 'skills', title: 'Skills', weight: 15 },\n     { id: 'projects', title: 'Projects', weight: 10 },\n     { id: 'certifications', title: 'Certifications', weight: 10 }\n   ];\n   ```\n\n3. Build Tiptap editor component for work history/project descriptions:\n   ```typescript\n   import { useEditor, EditorContent } from '@tiptap/react';\n   import StarterKit from '@tiptap/starter-kit';\n\n   const editor = useEditor({\n     extensions: [StarterKit],\n     content: initialContent,\n     onUpdate: ({ editor }) => {\n       // Auto-save logic\n     }\n   });\n   ```\n\n4. Implement progress calculation:\n   ```typescript\n   function calculateCompleteness(profile: Profile): number {\n     let score = 0;\n     if (profile.contactInfo.email) score += 10;\n     if (profile.workHistory.length > 0) score += 40;\n     if (profile.education.length > 0) score += 15;\n     if (profile.skills.length >= 5) score += 15;\n     if (profile.projects.length > 0) score += 10;\n     if (profile.certifications.length > 0) score += 10;\n     return score;\n   }\n   ```\n\n5. Create resume import feature using GPT-4 Vision:\n   ```typescript\n   async function importFromResume(file: File) {\n     const base64 = await fileToBase64(file);\n     const response = await openai.chat.completions.create({\n       model: 'gpt-5.1-vision-preview',\n       messages: [{\n         role: 'user',\n         content: [\n           { type: 'text', text: 'Extract structured profile data from this resume' },\n           { type: 'image_url', image_url: { url: base64 } }\n         ]\n       }]\n     });\n     return JSON.parse(response.choices[0].message.content);\n   }\n   ```\n\n6. Implement auto-save with debouncing (30 second intervals)\n7. Add JSON export functionality\n8. Create skill tag input with proficiency levels\n9. Build dynamic work history/education entry forms\n10. Create /profile route and wire ProfileBuilder component\n11. Connect to database for persistent storage\n12. Implement E2E tests",
        "testStrategy": "1. Test auto-save triggers after 30 seconds of inactivity\n2. Verify progress calculation updates correctly (0-100%)\n3. Test Tiptap editor saves rich text properly\n4. Validate resume import with sample PDF (check 80%+ accuracy)\n5. Test JSON export/import round-trip\n6. Verify all form validations work\n7. Test skill tag input (add/remove/edit)\n8. Confirm data persists to Profile table\n9. Test with incomplete profiles (partial data)\n10. Verify proficiency level dropdowns work\n11. E2E: Verify user can access /profile and save data\n12. E2E: Verify data persistence across sessions",
        "subtasks": [
          {
            "id": 1,
            "title": "Configure Tiptap Rich Text Editor with required extensions",
            "description": "Set up Tiptap editor with StarterKit and Placeholder extensions for profile content creation",
            "dependencies": [],
            "details": "Install @tiptap/react, @tiptap/starter-kit, and @tiptap/extension-placeholder; create reusable editor component with proper configuration for work history and project descriptions; implement placeholder text and content management",
            "status": "done",
            "testStrategy": "Verify editor renders correctly, all toolbar functions work, and content saves properly",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement multi-section profile form structure",
            "description": "Create the architecture for the profile form with all required sections and dynamic entry forms",
            "dependencies": [
              1
            ],
            "details": "Build the form structure with contact, work history, education, skills, projects, and certifications sections; implement dynamic forms for work history/education entries and skill tag input with proficiency levels; create JSON export functionality",
            "status": "done",
            "testStrategy": "Test navigation between sections, verify all form elements render correctly, validate dynamic entry creation/deletion",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Develop weighted progress calculation system",
            "description": "Implement the algorithm to calculate profile completeness based on section completion",
            "dependencies": [
              2
            ],
            "details": "Create function that calculates profile completeness score based on weighted sections (contact: 10%, work history: 40%, education: 15%, skills: 15%, projects: 10%, certifications: 10%); implement UI display for progress percentage\n<info added on 2025-11-20T00:26:39.290Z>\nPlan:\n1. Create job-search-platform/tests/unit/lib/profile-utils.test.ts.\n2. Write test: Verify score calculation (Contact=10, Work=40, etc.).\n3. Run npm test (Expect Fail).\n4. Create job-search-platform/src/lib/profile-utils.ts.\n5. Implement calculateCompleteness.\n6. Run npm test (Expect Pass).\n</info added on 2025-11-20T00:26:39.290Z>",
            "status": "done",
            "testStrategy": "Verify calculation returns correct percentages for various completion states, test edge cases like partial section completion",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement GPT-5.1 Vision resume parsing functionality",
            "description": "Create the feature to import profile data from resumes using GPT-4 Vision API",
            "dependencies": [
              2
            ],
            "details": "Build file upload handler, base64 conversion, API call to GPT-5.1 Vision with proper prompt engineering, and data mapping to profile structure; implement error handling for failed OCR attempts and validation of extracted data\n<info added on 2025-11-20T00:28:37.161Z>\nPlan:\n1. Create `job-search-platform/tests/unit/lib/resume-parser.test.ts`.\n2. Write test: `parseResume` calls OpenAI mock and returns parsed JSON.\n3. Run `npm test` (Expect Fail).\n4. Create `job-search-platform/src/lib/resume-parser.ts`.\n5. Implement parser logic (mocked OpenAI for now).\n6. Run `npm test` (Expect Pass).\n</info added on 2025-11-20T00:28:37.161Z>",
            "status": "done",
            "testStrategy": "Test with sample resumes in different formats, verify data extraction accuracy, validate error handling for corrupted files",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement auto-save functionality with debouncing",
            "description": "Create the auto-save system that triggers after 30 seconds of inactivity",
            "dependencies": [
              1,
              2
            ],
            "details": "Set up debouncing mechanism with 30-second interval, connect to editor onUpdate and form change events, implement save to backend with proper state management and error recovery; add visual indicators for save status\n<info added on 2025-11-20T00:30:35.286Z>\nPlan:\n1. Update `job-search-platform/tests/unit/components/profile/ProfileBuilder.test.tsx` to test for Auto-Save integration.\n2. Test: Check if `useAutoSave` triggers (mock it) or check for \"Saved\" indicator.\n3. Run `npm test` (Expect Fail).\n4. Update `job-search-platform/src/components/profile/ProfileBuilder.tsx` to integrate `useForm` and `useAutoSave`.\n5. Run `npm test` (Expect Pass).\n</info added on 2025-11-20T00:30:35.286Z>",
            "status": "done",
            "testStrategy": "Verify auto-save triggers after 30s inactivity, test with rapid typing, validate data persistence after page refresh",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2025-12-05T20:21:55.607Z"
      },
      {
        "id": "16",
        "title": "Develop LLM Integration Layer with Multi-Provider Support",
        "description": "Build the provider-agnostic LLM client using LangChain that supports OpenAI, Anthropic, Ollama, OpenRouter, Azure OpenAI, and custom endpoints with configurable temperature/token settings and resume generation prompts.",
        "status": "done",
        "dependencies": [
          "15"
        ],
        "priority": "high",
        "details": "1. Install LangChain dependencies:\n   ```bash\n   npm install @langchain/openai @langchain/anthropic @langchain/community\n   npm install langchain\n   ```\n\n2. Create LLM client factory:\n   ```typescript\n   // src/lib/llm.ts\n   import { ChatOpenAI } from '@langchain/openai';\n   import { ChatAnthropic } from '@langchain/anthropic';\n\n   export interface LLMConfig {\n     provider: 'openai' | 'anthropic' | 'ollama' | 'openrouter' | 'azure' | 'custom';\n     model: string;\n     temperature: number;\n     maxTokens: number;\n     apiKey?: string;\n     apiEndpoint?: string;\n   }\n\n   export function getLLMClient(config: LLMConfig) {\n     switch (config.provider) {\n       case 'openai':\n         return new ChatOpenAI({\n           modelName: config.model,\n           temperature: config.temperature,\n           maxTokens: config.maxTokens,\n           openAIApiKey: config.apiKey || process.env.OPENAI_API_KEY,\n         });\n       case 'anthropic':\n         return new ChatAnthropic({\n           modelName: config.model,\n           temperature: config.temperature,\n           maxTokens: config.maxTokens,\n           anthropicApiKey: config.apiKey || process.env.ANTHROPIC_API_KEY,\n         });\n       case 'ollama':\n         return new ChatOpenAI({\n           modelName: config.model,\n           temperature: config.temperature,\n           maxTokens: config.maxTokens,\n           configuration: {\n             baseURL: config.apiEndpoint || process.env.OLLAMA_BASE_URL || 'http://localhost:11434/v1',\n           },\n         });\n       case 'custom':\n         return new ChatOpenAI({\n           modelName: config.model,\n           temperature: config.temperature,\n           maxTokens: config.maxTokens,\n           openAIApiKey: config.apiKey,\n           configuration: {\n             baseURL: config.apiEndpoint,\n           },\n         });\n       default:\n         throw new Error(`Unsupported provider: ${config.provider}`);\n     }\n   }\n   ```\n\n3. Create resume generation service:\n   ```typescript\n   // src/lib/resume-generator.ts\n   export async function generateTailoredResume(\n     jobDescription: string,\n     userProfile: Profile,\n     exaggerationLevel: 'conservative' | 'balanced' | 'strategic',\n     llmConfig: LLMConfig\n   ) {\n     const llm = getLLMClient(llmConfig);\n     \n     const systemPrompt = `You are an expert resume writer. Given a job description and a candidate's master profile, generate a tailored resume that:\n     1. Highlights relevant experience for this specific role\n     2. Uses keywords from the job description naturally\n     3. Reorders work history to prioritize relevant roles\n     4. Adjusts tone based on exaggeration level: ${exaggerationLevel}\n        - Conservative: Factual, no embellishment\n        - Balanced: Professional emphasis\n        - Strategic: Confident, persuasive\n     \n     Output should be ATS-friendly markdown format.`;\n\n     const userPrompt = `Job Description:\\n${jobDescription}\\n\\nCandidate Profile:\\n${JSON.stringify(userProfile)}\\n\\nGenerate tailored resume sections: Summary, Experience, Skills, Education.`;\n\n     const response = await llm.invoke([\n       { role: 'system', content: systemPrompt },\n       { role: 'user', content: userPrompt }\n     ]);\n\n     return response.content;\n   }\n   ```\n\n4. Map exaggeration levels to temperature:\n   - Conservative: 0.3\n   - Balanced: 0.5\n   - Strategic: 0.7\n\n5. Create LLM connection test endpoint\n6. Implement error handling and retry logic\n7. Add streaming support for real-time generation\n8. Perform end-to-end integration verification with Settings page",
        "testStrategy": "1. Test each provider (OpenAI, Anthropic, Ollama) with valid API keys\n2. Verify temperature mapping affects output tone\n3. Test resume generation with sample job description + profile\n4. Validate markdown output is ATS-friendly\n5. Test connection test endpoint for each provider\n6. Verify error handling for invalid API keys\n7. Test retry logic on API failures\n8. Confirm streaming works for real-time updates\n9. Test custom endpoint configuration\n10. Validate token limits are respected\n11. Verify end-to-end flow from Settings page (API key entry -> Connection Test -> Generation)",
        "subtasks": [
          {
            "id": 1,
            "title": "Design Provider-Agnostic LLM Client Interface",
            "description": "Create the foundational interface and configuration structure for the multi-provider LLM client",
            "dependencies": [],
            "details": "Define LLMConfig interface with provider types, model parameters, and exaggeration level mapping. Establish TypeScript interfaces that abstract provider-specific implementations. Create the getLLMClient factory function skeleton with proper typing and dependency management.",
            "status": "done",
            "testStrategy": "Validate interface compatibility with all target providers through TypeScript compilation checks",
            "parentId": "undefined",
            "updatedAt": "2025-11-20T17:40:50.572Z"
          },
          {
            "id": 2,
            "title": "Implement Individual Provider Adapters",
            "description": "Build concrete implementations for each LLM provider with proper configuration handling",
            "dependencies": [
              1
            ],
            "details": "Complete the getLLMClient factory with implementations for OpenAI, Anthropic, Ollama, OpenRouter, Azure OpenAI, and custom endpoints. Handle provider-specific configuration parameters, API key management, and endpoint URLs. Ensure proper error handling for missing credentials and invalid configurations.",
            "status": "done",
            "testStrategy": "Test each provider implementation with valid API keys and verify client initialization works correctly",
            "parentId": "undefined",
            "updatedAt": "2025-11-20T18:14:13.226Z"
          },
          {
            "id": 3,
            "title": "Engineer Resume Generation Prompt System",
            "description": "Develop the prompt engineering system for tailored resume generation with exaggeration levels",
            "dependencies": [
              1,
              2
            ],
            "details": "Implement generateTailoredResume function with dynamic system prompts based on exaggeration levels. Map exaggeration levels to temperature parameters (Conservative: 0.3, Balanced: 0.5, Strategic: 0.7). Structure prompts to highlight relevant experience, use job description keywords, and reorder work history while maintaining ATS-friendly format.\n<info added on 2025-11-20T18:28:07.771Z>\nPlan: Develop the prompt engineering system for tailored resume generation with exaggeration levels.\n\nImplementation steps:\n1. Analyze existing ResumeGenerator class structure and interfaces\n2. Design prompt engineering system architecture with modular prompt components\n3. Create dynamic system prompts based on exaggeration levels (conservative, balanced, strategic)\n4. Map exaggeration levels to temperature parameters (Conservative: 0.3, Balanced: 0.5, Strategic: 0.7)\n5. Implement generateTailoredResume function with comprehensive prompt engineering\n6. Structure prompts to highlight relevant experience and use job description keywords\n7. Create ATS-friendly markdown format templates and structures\n8. Implement work history reordering logic based on job relevance\n9. Add keyword extraction and integration from job descriptions\n10. Test with sample job descriptions and profiles\n11. Validate ATS-friendly markdown output format\n12. Test exaggeration level effects on generated tone\n\nFiles to modify:\n- src/lib/llm.ts (implement generateTailoredResume and generateTailoredResumeStream methods)\n\nThis will enable intelligent resume tailoring that adapts tone and content based on user-defined exaggeration levels while maintaining ATS compatibility.\n</info added on 2025-11-20T18:28:07.771Z>",
            "status": "done",
            "testStrategy": "Test prompt outputs with sample job descriptions and profiles, verify ATS-friendly markdown format, and validate exaggeration level effects on tone",
            "parentId": "undefined",
            "updatedAt": "2025-11-20T18:31:54.479Z"
          },
          {
            "id": 4,
            "title": "Build LLM Connection Testing Framework",
            "description": "Create endpoint and utilities for testing LLM provider connections",
            "dependencies": [
              1,
              2
            ],
            "details": "Implement connection test endpoint that validates API connectivity for each provider. Include tests for authentication, model availability, and basic response generation. Provide clear error messages for different failure scenarios including network issues and invalid credentials.\n<info added on 2025-11-20T18:36:08.196Z>\nPlan: Build comprehensive LLM connection testing framework with endpoint and utilities.\n\nImplementation steps:\n1. Analyze existing LLMClient testConnection methods across all providers\n2. Create connection testing utilities with enhanced error categorization\n3. Build API endpoint /api/llm/test-connection for real-time connection testing\n4. Implement batch connection testing for multiple providers\n5. Add detailed error message categorization (auth errors, network errors, model availability)\n6. Create configuration validation utilities for all provider types\n7. Implement timeout handling and retry logic for connection tests\n8. Build test scenarios including valid/invalid credentials and network failures\n9. Create connection status reporting with detailed diagnostics\n10. Add integration with existing LLM configuration system\n\nFiles to create/modify:\n- src/app/api/llm/test-connection/route.ts (new API endpoint)\n- src/lib/llm-testing.ts (new testing utilities)\n- src/lib/llm.ts (enhance connection testing if needed)\n- tests/lib/llm-testing.test.ts (comprehensive test suite)\n\nThis will provide robust connection testing capabilities with clear error reporting for all supported LLM providers, enabling users to validate their configuration and troubleshoot connectivity issues effectively.\n</info added on 2025-11-20T18:36:08.196Z>\n<info added on 2025-11-20T18:41:24.144Z>\nTask completed successfully.\n\nImplementation Summary:\nCreated comprehensive LLM connection testing framework with endpoint and utilities.\n\n1. Enhanced Connection Testing Utilities (src/lib/llm-testing.ts):\n- LLMConnectionTester class with advanced error categorization\n- DetailedConnectionTest and BatchConnectionTest interfaces\n- ConnectionTestError class with proper typing\n- Utility functions: quickConnectionTest, comprehensiveConnectionTest, testAllProviders\n\n2. API Endpoint (src/app/api/llm/test-connection/route.ts):\n- POST endpoint for connection testing (single, batch, quick, and comprehensive modes)\n- GET endpoint for configuration validation\n- Authentication and comprehensive error handling implemented\n\n3. Error Categorization System:\n- Covers authentication, network, configuration, model_unavailable, timeout, and unknown errors\n\n4. Advanced Features:\n- Configurable timeouts and retry logic with exponential backoff\n- Diagnostic information collection\n- Provider-specific configuration validation\n- Batch testing with statistics\n\n5. Test Coverage (tests/lib/llm-testing.test.ts):\n- Includes configuration validation, single/batch connection tests, error categorization, and mock implementations\n\nThe framework supports OpenAI, Anthropic, Ollama, OpenRouter, Azure, and Custom providers, enabling effective configuration validation and troubleshooting. All files follow existing project patterns and TypeScript best practices.\n</info added on 2025-11-20T18:41:24.144Z>\n<info added on 2025-11-21T17:51:40.881Z>\nCompleted LLM connection testing framework. Hardened llm-testing utilities including error categorization, diagnostics, batch statistics, and retry mechanisms. Aligned types for structured errors and minimal tester implementation. Added unit coverage for connection testing suites.\n</info added on 2025-11-21T17:51:40.881Z>",
            "status": "done",
            "testStrategy": "Verify connection tests work for valid and invalid credentials across all providers, test network failure scenarios",
            "parentId": "undefined",
            "updatedAt": "2025-11-21T17:51:48.255Z"
          },
          {
            "id": 5,
            "title": "Implement Error Handling and Streaming Support",
            "description": "Add robust error handling, retry logic, and real-time streaming capabilities",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "Implement retry logic with exponential backoff for API failures. Add comprehensive error handling for rate limits, authentication issues, and timeouts. Integrate streaming support for real-time resume generation updates using LangChain's streaming capabilities and proper chunk handling.",
            "status": "done",
            "testStrategy": "Test error scenarios including invalid API keys, rate limits, and network failures. Verify streaming works correctly and provides real-time updates",
            "parentId": "undefined",
            "updatedAt": "2025-11-21T21:21:16.949Z"
          },
          {
            "id": 6,
            "title": "Verify End-to-End Integration with Settings UI",
            "description": "Validate full integration between LLM backend and Settings page, ensuring connection tests and resume generation work as expected",
            "dependencies": [
              5
            ],
            "details": "Conduct end-to-end testing to verify that the LLM integration layer functions correctly when interacted with via the Settings page. Ensure that: 1. API keys provided in the Settings UI are correctly used for authentication. 2. The Connection Test feature in Settings returns success for valid credentials. 3. The resume generation process can be initiated and produces non-empty, valid output. 4. Verify that the system handles configuration changes (hot reload) correctly without restart.\n<info added on 2025-12-09T02:17:58.419Z>\nVerification complete: Created E2E test at tests/integration/llm-settings-e2e.test.ts. API endpoint /api/llm/test verified operational via curl. SettingsPage correctly integrates LLMSettings with all required fields. Test Connection button implemented. Note: Full live API test pending user configuration of OPENAI_API_KEY and ANTHROPIC_API_KEY in .env.\n</info added on 2025-12-09T02:17:58.419Z>",
            "status": "done",
            "testStrategy": "Manual verification via Settings UI: Enter keys, test connection, generate sample resume. Check logs for proper config loading.",
            "parentId": "undefined",
            "updatedAt": "2025-12-10T00:02:29.252Z"
          }
        ],
        "updatedAt": "2025-12-10T00:02:29.252Z"
      },
      {
        "id": "17",
        "title": "Build Job Aggregation System with n8n Workflows and Geocoding",
        "description": "Implement automated job scraping from Indeed, LinkedIn, and company career pages using n8n workflows, integrate Mapbox Geocoding API for location processing, persist scraped data to the PostgreSQL database, and integrate the real data feed into the /jobs UI.",
        "status": "in-progress",
        "dependencies": [
          "12"
        ],
        "priority": "high",
        "details": "1. Create n8n workflows for each job source:\n   - Indeed RSS feed workflow\n   - LinkedIn Jobs scraping workflow (using HTTP Request nodes)\n   - Company career page scraping (configurable URLs)\n\n2. Set up Mapbox Geocoding integration:\n   ```typescript\n   // src/lib/geocoding.ts\n   import mapboxgl from 'mapbox-gl';\n\n   export async function geocodeCity(cityName: string): Promise<{ lat: number; lng: number }> {\n     const response = await fetch(\n       `https://api.mapbox.com/geocoding/v5/mapbox.places/${encodeURIComponent(cityName)}.json?access_token=${process.env.NEXT_PUBLIC_MAPBOX_TOKEN}`\n     );\n     const data = await response.json();\n     const [lng, lat] = data.features[0].center;\n     return { lat, lng };\n   }\n   ```\n\n3. Implement Haversine distance calculation.\n\n4. Create job filtering service.\n\n5. Implement deduplication using fuzzy matching (title + company).\n\n6. Create composite scoring system.\n\n7. Set up cron job to run every 6 hours.\n\n8. **Database Persistence**: Implement a service to save processed, geocoded, and scored jobs into the PostgreSQL database using Prisma. Ensure proper field mapping and upsert logic.\n\n9. **UI Integration**: Connect the `/jobs` page to the real database, ensuring that scraped jobs are displayed correctly and that the UI reflects the production data state.",
        "testStrategy": "1. Test n8n workflows fetch jobs from each source\n2. Verify Mapbox geocoding returns correct coordinates\n3. Test Haversine distance calculation accuracy\n4. Validate geographic filtering (jobs within radius)\n5. Test temporal filtering (only jobs within X hours)\n6. Verify keyword filtering (include OR, exclude AND NOT)\n7. Test salary parsing and filtering\n8. Validate deduplication removes duplicates\n9. Test composite scoring calculation\n10. Verify cron job runs every 6 hours\n11. Test manual trigger endpoint\n12. **Verify Database Persistence**: Check that scraped jobs are correctly inserted into the `Job` table in PostgreSQL.\n13. **Verify UI Display**: Confirm that the `/jobs` page renders the list of jobs fetched from the real database.",
        "subtasks": [
          {
            "id": 1,
            "title": "Design and implement n8n workflows for job scraping from multiple sources",
            "description": "Create and configure n8n workflows to scrape job listings from Indeed RSS feed, LinkedIn Jobs, and configurable company career pages",
            "dependencies": [],
            "details": "Implement three separate workflows: 1) Indeed RSS feed workflow using RSS node, 2) LinkedIn Jobs scraping workflow using HTTP Request nodes with proper headers and pagination, 3) Company career page scraping workflow with configurable URL templates and CSS selectors. Each workflow must extract title, company, location, description, salary, and posting date.",
            "status": "done",
            "testStrategy": "Test each workflow individually with sample URLs, verify data extraction completeness, check error handling for failed requests, validate output structure matches expected schema",
            "parentId": "undefined",
            "updatedAt": "2025-12-04T15:31:00.061Z"
          },
          {
            "id": 2,
            "title": "Integrate Mapbox Geocoding API with error handling and caching",
            "description": "Implement Mapbox Geocoding service to convert job locations to latitude/longitude coordinates with rate limiting and caching",
            "dependencies": [],
            "details": "Create geocoding service using provided TypeScript implementation, add rate limiting to respect Mapbox API limits, implement Redis caching for previously geocoded locations, handle API errors and retries, and add circuit breaker pattern for API failures.",
            "status": "done",
            "testStrategy": "Test with various location formats (city names, addresses), verify cache hits/misses, test error scenarios (invalid locations, API rate limits), validate coordinate accuracy against known locations",
            "parentId": "undefined",
            "updatedAt": "2025-12-04T15:31:00.092Z"
          },
          {
            "id": 3,
            "title": "Implement geographic filtering using Haversine formula with configurable radius",
            "description": "Develop geographic filtering functionality using Haversine distance calculation to filter jobs within specified radius of target locations",
            "dependencies": [
              2
            ],
            "details": "Implement the provided Haversine distance calculation function, create geographic filtering service that processes jobs against user-defined search areas (cities with radius), handle cases where job locations can't be geocoded, and optimize for performance with spatial indexing where possible.",
            "status": "done",
            "testStrategy": "Test with known coordinate pairs and verified distances, validate edge cases (antipodal points, same location), test performance with large job datasets, verify filtering accuracy against manual calculations",
            "parentId": "undefined",
            "updatedAt": "2025-12-04T15:31:00.116Z"
          },
          {
            "id": 4,
            "title": "Develop composite scoring algorithm for job relevance ranking",
            "description": "Create scoring system that ranks jobs based on multiple criteria including recency, keyword relevance, salary, and geographic proximity",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Implement weighted scoring system where each criterion (recency, keyword match strength, salary level, geographic proximity) contributes to overall relevance score. Allow configurable weights through system settings. Normalize scores across different criteria for fair comparison.",
            "status": "done",
            "testStrategy": "Test with controlled datasets where expected ranking is known, verify weight adjustments affect results as expected, test edge cases (jobs with missing data), validate score distribution across large datasets",
            "parentId": "undefined",
            "updatedAt": "2025-12-04T15:31:00.147Z"
          },
          {
            "id": 5,
            "title": "Create deduplication system using fuzzy matching on job titles and companies",
            "description": "Implement job deduplication functionality using fuzzy string matching to identify and merge duplicate job listings from different sources",
            "dependencies": [
              1
            ],
            "details": "Develop fuzzy matching algorithm using Levenshtein distance or similar technique to compare job titles and company names. Implement configurable similarity thresholds. Create merge strategy for duplicate jobs that preserves the most complete information from each source.",
            "status": "done",
            "testStrategy": "Test with known duplicate job pairs with varying degrees of similarity, verify threshold adjustments affect deduplication results, test performance with large job datasets, validate merged job data integrity",
            "parentId": "undefined",
            "updatedAt": "2025-12-04T15:31:00.169Z"
          },
          {
            "id": 6,
            "title": "Set up scheduling system with monitoring and error reporting",
            "description": "Configure cron-based scheduling for regular job aggregation runs with comprehensive monitoring and alerting capabilities",
            "dependencies": [
              1,
              2,
              3,
              4,
              5
            ],
            "details": "Implement cron scheduler to run aggregation every 6 hours, create monitoring dashboard showing success rates and performance metrics, set up error notifications via email/Slack, implement retry logic for failed jobs, and create manual trigger API endpoint for on-demand runs.",
            "status": "done",
            "testStrategy": "Test scheduling with shortened intervals, verify monitoring metrics are accurately recorded, test error notification channels, validate retry logic works as expected, test manual trigger API endpoint functionality",
            "parentId": "undefined",
            "updatedAt": "2025-12-04T15:31:00.186Z"
          },
          {
            "id": 7,
            "title": "Implement Database Persistence Service for Aggregated Jobs",
            "description": "Develop the service layer to persist processed job data into PostgreSQL using Prisma, ensuring data integrity and proper mapping",
            "dependencies": [
              1,
              5,
              6
            ],
            "details": "Create a `JobService` or repository that accepts the output from the aggregation pipeline. Map the internal job objects to the Prisma `Job` model defined in Task 12. Implement `upsert` logic to handle existing jobs (updating them if changed) and insert new ones. Ensure all fields including location coordinates, salary, and calculated scores are correctly persisted to the database.\n<info added on 2025-12-12T23:34:24.519Z>\nCreate job-service.ts with a saveJobs() function that accepts JobListing[] and persists to the DB using Prisma. Add a unique constraint to the sourceUrl field to prevent duplicates. Implement geocoding integration to fetch coordinates. Write comprehensive unit tests. Ensure geocoding API errors are handled gracefully.\n</info added on 2025-12-12T23:34:24.519Z>",
            "status": "in-progress",
            "testStrategy": "Run the aggregation pipeline and verify that records are created in the local PostgreSQL database. Check for correct field mapping. Verify that re-running the pipeline updates existing records without creating duplicates.",
            "parentId": "undefined",
            "updatedAt": "2025-12-12T23:34:31.036Z"
          },
          {
            "id": 8,
            "title": "Connect /jobs UI to Real Database and Verify Display",
            "description": "Update the jobs dashboard to fetch and display live data from the database, replacing any mock data sources",
            "dependencies": [
              7
            ],
            "details": "Modify the data fetching strategy on the `/jobs` route (using Server Components or Actions) to query the real `Job` table via Prisma. Ensure that the frontend components correctly render the data fetched from the DB. Verify that the page displays the jobs that were scraped and saved in Subtask 7.",
            "status": "pending",
            "testStrategy": "Navigate to the `/jobs` page in a production-like environment (non-mock mode). Verify that the list of jobs matches the data in the database. Check that job details (title, company, location) are displayed correctly.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2025-12-12T23:34:31.036Z"
      },
      {
        "id": "18",
        "title": "Create Interactive Map Visualization with Mapbox GL JS",
        "description": "Build the geographic job visualization using Mapbox GL JS with color-coded markers, radius circles, density heatmap, clustering, popups, and mobile-optimized touch controls. Integrate into the application via the /map route, displaying real job data from the database and accessible via main navigation.",
        "status": "done",
        "dependencies": [
          "17"
        ],
        "priority": "high",
        "details": "1. Install Mapbox dependencies:\n   ```bash\n   npm install mapbox-gl react-map-gl\n   npm install -D @types/mapbox-gl\n   ```\n\n2. Create Map component:\n   ```typescript\n   // src/components/map/JobMap.tsx\n   import Map, { Marker, Source, Layer, Popup } from 'react-map-gl';\n   import 'mapbox-gl/dist/mapbox-gl.css';\n\n   export function JobMap({ jobs, cities, filters }) {\n     // ... implementation details\n   }\n   ```\n\n3. Implement marker color coding based on composite score.\n4. Add clustering for nearby jobs.\n5. Create heatmap layer (toggleable).\n6. Implement mobile touch gestures.\n7. Add filter controls (status, date range, score threshold).\n8. Create dark/light theme toggle.\n\n9. Create Page Route:\n   ```typescript\n   // src/app/map/page.tsx\n   import { JobMap } from '@/components/map/JobMap';\n   import { getJobs } from '@/lib/api/jobs';\n\n   export default async function MapPage() {\n     const jobs = await getJobs();\n     return <JobMap jobs={jobs} ... />;\n   }\n   ```\n\n10. Update Navigation: Add link to /map in Navbar component.",
        "testStrategy": "1. Verify map loads with correct initial view\n2. Test marker rendering for all jobs\n3. Validate color coding (green/yellow/red by score)\n4. Test radius circles display correctly\n5. Verify clustering works (groups nearby markers)\n6. Test popup opens on marker click\n7. Validate heatmap toggle functionality\n8. Test mobile touch gestures (pinch/zoom)\n9. Verify filters update map in real-time\n10. Test theme toggle (dark/light mode)\n11. Check performance with 500+ markers\n12. Verify /map route is accessible\n13. Validate real data loads from database\n14. Test navigation link works",
        "subtasks": [
          {
            "id": 1,
            "title": "Set up Mapbox GL JS integration and base map configuration",
            "description": "Install dependencies, configure Mapbox token, and initialize the base map component with proper styling and view state management",
            "dependencies": [],
            "details": "Install mapbox-gl and react-map-gl packages, create JobMap component with TypeScript typing, configure dark-v11 map style, implement viewState management with useState, and ensure proper CSS imports",
            "status": "done",
            "testStrategy": "Verify map loads with correct initial view, check token authentication works, validate CSS styles are properly applied",
            "parentId": "undefined",
            "updatedAt": "2025-12-04T15:31:07.145Z"
          },
          {
            "id": 2,
            "title": "Implement color-coded job markers with clustering functionality",
            "description": "Create color-coded markers based on job scores and implement clustering for dense job locations with proper visual representation",
            "dependencies": [
              1
            ],
            "details": "Implement getMarkerColor function for score-based coloring, create marker components with proper styling, configure clustering with clusterMaxZoom=14 and clusterRadius=50, implement cluster layers for both cluster points and counts",
            "status": "done",
            "testStrategy": "Test marker rendering for all jobs, validate color coding (green/yellow/red by score), verify clustering works (groups nearby markers), check cluster count display",
            "parentId": "undefined",
            "updatedAt": "2025-12-04T15:31:07.165Z"
          },
          {
            "id": 3,
            "title": "Develop city radius circle visualization with proper styling",
            "description": "Create and render radius circles around configured cities with appropriate fill and border styling as specified in requirements",
            "dependencies": [
              1
            ],
            "details": "Implement createCircle utility function to generate GeoJSON for city radii, add Source and Layer components for both fill and line representations, apply proper styling with blue color (#3b82f6) and appropriate opacity/width values",
            "status": "done",
            "testStrategy": "Validate radius circles display correctly around cities, verify styling matches requirements, test with multiple cities of different radii",
            "parentId": "undefined",
            "updatedAt": "2025-12-04T15:31:07.187Z"
          },
          {
            "id": 4,
            "title": "Implement mobile-optimized touch controls and responsive design",
            "description": "Add support for mobile touch gestures including pinch/zoom, swipe navigation, and ensure proper responsive behavior across device sizes",
            "dependencies": [
              1
            ],
            "details": "Configure Map component with touchZoomRotate and dragPan enabled, implement responsive breakpoints for different screen sizes, add mobile-specific UI adjustments for markers and popups, ensure proper touch event handling",
            "status": "done",
            "testStrategy": "Test pinch/zoom functionality on mobile devices, verify swipe navigation works, check popup behavior on touch events, validate responsive layout across device sizes",
            "parentId": "undefined",
            "updatedAt": "2025-12-04T15:31:07.204Z"
          },
          {
            "id": 5,
            "title": "Optimize map performance for large job datasets (500+ markers)",
            "description": "Implement performance optimizations to ensure smooth rendering and interaction with large datasets of job locations",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Implement data filtering based on current viewport, optimize GeoJSON data structure, use Mapbox's feature filtering capabilities, implement lazy loading for markers outside current view, optimize React component rendering with memoization",
            "status": "done",
            "testStrategy": "Benchmark performance with 500+ job markers, verify frame rate remains above 30fps during interactions, test memory usage during extended use, validate smooth transitions during zoom/pan operations",
            "parentId": "undefined",
            "updatedAt": "2025-12-04T15:31:07.225Z"
          },
          {
            "id": 6,
            "title": "Create /map route and page wrapper",
            "description": "Implement the /map route using the application router and wrap the JobMap component for display.",
            "dependencies": [
              1
            ],
            "details": "Create src/app/map/page.tsx (or equivalent), import the JobMap component, ensure proper layout wrapping, and verify route accessibility.",
            "status": "pending",
            "testStrategy": "Verify /map route loads the map component correctly without errors.",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "Integrate real job data from database",
            "description": "Connect the map visualization to the actual job database instead of mock data.",
            "dependencies": [
              6
            ],
            "details": "Fetch job data using server actions or API hooks, transform database records to GeoJSON format required by Mapbox, handle loading states and empty data scenarios.",
            "status": "pending",
            "testStrategy": "Validate that markers on the map correspond to actual records in the database.",
            "parentId": "undefined"
          },
          {
            "id": 8,
            "title": "Add Map to main navigation",
            "description": "Update the global navigation menu to include a link to the Map visualization.",
            "dependencies": [
              6
            ],
            "details": "Add 'Map' item to the main Navbar/Sidebar, ensure active state highlighting when on the /map route, and verify navigation links work.",
            "status": "pending",
            "testStrategy": "Click Map link in navigation and verify correct routing and active state styling.",
            "parentId": "undefined"
          },
          {
            "id": 9,
            "title": "Implement advanced map controls (Heatmap, Filters, Theme)",
            "description": "Add the remaining interactive controls including heatmap toggle, job filters, and theme switching.",
            "dependencies": [
              2,
              7
            ],
            "details": "Implement heatmap layer toggling, add filter UI for status/date/score, and implement dark/light mode switching for the map style.",
            "status": "pending",
            "testStrategy": "Test toggling heatmap, applying filters updates markers, and switching themes changes map style.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2025-12-05T20:55:02.962Z"
      },
      {
        "id": "19",
        "title": "Implement Kanban Application Pipeline Tracker with Drag-and-Drop",
        "description": "Build the application tracking system using dnd-kit with customizable pipeline stages, drag-and-drop functionality, status timeline, file attachments, notes, bulk operations, and CSV export as specified in the PRD.",
        "status": "done",
        "dependencies": [
          "12"
        ],
        "priority": "high",
        "details": "1. Install dnd-kit dependencies:\n   ```bash\n   npm install @dnd-kit/core @dnd-kit/sortable @dnd-kit/utilities\n   ```\n\n2. Create Kanban board component:\n   ```typescript\n   // src/components/pipeline/KanbanBoard.tsx\n   import { DndContext, DragOverlay, closestCorners } from '@dnd-kit/core';\n   import { SortableContext, verticalListSortingStrategy } from '@dnd-kit/sortable';\n\n   const stages = [\n     { id: 'discovered', title: 'Discovered', color: 'gray' },\n     { id: 'interested', title: 'Interested', color: 'blue' },\n     { id: 'applied', title: 'Applied', color: 'yellow' },\n     { id: 'interview', title: 'Interview', color: 'purple' },\n     { id: 'offer', title: 'Offer', color: 'green' },\n     { id: 'rejected', title: 'Rejected', color: 'red' },\n     { id: 'archived', title: 'Archived', color: 'gray' }\n   ];\n\n   export function KanbanBoard({ applications }) {\n     const [activeId, setActiveId] = useState(null);\n\n     function handleDragStart(event) {\n       setActiveId(event.active.id);\n     }\n\n     async function handleDragEnd(event) {\n       const { active, over } = event;\n       if (!over) return;\n\n       const applicationId = active.id;\n       const newStatus = over.id;\n\n       await updateApplicationStatus(applicationId, newStatus);\n     }\n\n     return (\n       <DndContext\n         collisionDetection={closestCorners}\n         onDragStart={handleDragStart}\n         onDragEnd={handleDragEnd}\n       >\n         <div className=\"flex gap-4 overflow-x-auto\">\n           {stages.map(stage => (\n             <Column\n               key={stage.id}\n               stage={stage}\n               applications={applications.filter(app => app.status === stage.id)}\n             />\n           ))}\n         </div>\n       </DndContext>\n     );\n   }\n   ```\n\n3. Create application card component:\n   ```typescript\n   function ApplicationCard({ application }) {\n     return (\n       <div className=\"bg-white p-4 rounded shadow\">\n         <h3>{application.job.title}</h3>\n         <p>{application.job.company}</p>\n         <div className=\"flex gap-2 mt-2\">\n           <button onClick={() => generateResume(application)}>Generate Resume</button>\n           <button onClick={() => markAsApplied(application)}>Mark Applied</button>\n           <button onClick={() => archiveApplication(application)}>Archive</button>\n         </div>\n         <div className=\"mt-2\">\n           <input\n             type=\"file\"\n             onChange={(e) => attachFile(application, e.target.files[0])}\n           />\n           <textarea\n             placeholder=\"Add notes...\"\n             value={application.notes}\n             onChange={(e) => updateNotes(application, e.target.value)}\n           />\n         </div>\n       </div>\n     );\n   }\n   ```\n\n4. Implement status change timeline:\n   ```typescript\n   async function updateApplicationStatus(id: string, newStatus: string) {\n     const application = await prisma.application.findUnique({ where: { id } });\n     const statusHistory = [\n       ...application.statusHistory,\n       { status: newStatus, timestamp: new Date() }\n     ];\n     await prisma.application.update({\n       where: { id },\n       data: { status: newStatus, statusHistory, updatedAt: new Date() }\n     });\n   }\n   ```\n\n5. Add bulk operations (select multiple â†’ archive/delete)\n6. Implement search/filter functionality\n7. Create CSV export feature\n8. Add daily application cap enforcement",
        "testStrategy": "1. Test drag-and-drop between all stages\n2. Verify status updates persist to database\n3. Test status timeline shows all changes\n4. Validate file attachment upload and storage\n5. Test notes auto-save functionality\n6. Verify quick actions (Generate Resume, Mark Applied, Archive)\n7. Test bulk operations (select multiple cards)\n8. Validate search/filter updates board\n9. Test CSV export contains all data\n10. Verify daily cap prevents exceeding limit\n11. Test mobile responsiveness (horizontal scroll)",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement dnd-kit core functionality for drag-and-drop",
            "description": "Set up dnd-kit library with proper collision detection, drag handlers, and state management for the Kanban board",
            "dependencies": [],
            "details": "Install required dnd-kit packages, configure DndContext with collision detection strategy, implement drag start/end handlers, and set up state management for drag operations between pipeline stages",
            "status": "done",
            "testStrategy": "Verify drag-and-drop works between all columns, test edge cases like rapid dragging, validate smooth UI transitions during drag operations",
            "parentId": "undefined",
            "updatedAt": "2025-12-03T23:57:14.718Z"
          },
          {
            "id": 2,
            "title": "Develop Kanban board structure and application card components",
            "description": "Create the visual layout of the Kanban board with customizable stages and design the application card UI with all required features",
            "dependencies": [
              1
            ],
            "details": "Implement Column component for pipeline stages, ApplicationCard component with job details, action buttons, file attachment input, and notes textarea. Style components using Tailwind CSS with responsive design considerations",
            "status": "done",
            "testStrategy": "Validate responsive layout across device sizes, test all UI elements are accessible, verify all interactive elements function correctly",
            "parentId": "undefined",
            "updatedAt": "2025-12-03T23:57:14.725Z"
          },
          {
            "id": 3,
            "title": "Implement application status timeline and history tracking",
            "description": "Create functionality to track and display the complete status history of each application with timestamps",
            "dependencies": [
              1,
              2
            ],
            "details": "Design database schema for status history, implement updateApplicationStatus function that records timeline entries with proper database transactions, create UI component to display status history in a timeline format with visual indicators",
            "status": "done",
            "testStrategy": "Test status changes are properly recorded with timestamps, verify timeline displays correctly, validate data persists through application restarts",
            "parentId": "undefined",
            "updatedAt": "2025-12-03T23:57:14.729Z"
          },
          {
            "id": 4,
            "title": "Implement bulk operations and CSV export features",
            "description": "Add functionality to select multiple applications for bulk actions and implement CSV export of application data",
            "dependencies": [
              2,
              3
            ],
            "details": "Create selection mechanism for multiple applications with visual feedback, implement bulk archive/delete operations with confirmation dialogs, develop CSV export functionality with proper data formatting, headers, and download handling",
            "status": "done",
            "testStrategy": "Test bulk selection and operations with various application counts, validate CSV format matches requirements, verify exported data matches application state",
            "parentId": "undefined",
            "updatedAt": "2025-12-03T23:57:14.737Z"
          }
        ],
        "updatedAt": "2025-12-03T23:57:14.737Z"
      },
      {
        "id": "20",
        "title": "Build Resume Generation and PDF Export System",
        "description": "Create the resume tailoring interface at /resume with live preview using ProseMirror editor, integrate with LLM service for generation, implement ATS-friendly PDF export with react-pdf, and add configurable file naming templates.",
        "status": "pending",
        "dependencies": [
          "16",
          "19"
        ],
        "priority": "medium",
        "details": "1. Install PDF generation dependencies:\n   ```bash\n   npm install @react-pdf/renderer react-pdf\n   npm install prosemirror-state prosemirror-view prosemirror-model\n   ```\n\n2. Create resume preview component:\n   ```typescript\n   // src/components/resume/ResumePreview.tsx\n   import { Document, Page, Text, View, StyleSheet, PDFDownloadLink } from '@react-pdf/renderer';\n\n   const styles = StyleSheet.create({\n     page: { padding: 30, fontFamily: 'Helvetica' },\n     section: { marginBottom: 10 },\n     heading: { fontSize: 18, fontWeight: 'bold', marginBottom: 5 },\n     text: { fontSize: 11, lineHeight: 1.5 }\n   });\n\n   function ResumePDF({ content }) {\n     return (\n       <Document>\n         <Page size=\"A4\" style={styles.page}>\n           <View style={styles.section}>\n             <Text style={styles.heading}>{content.name}</Text>\n             <Text style={styles.text}>{content.email} | {content.phone}</Text>\n           </View>\n           <View style={styles.section}>\n             <Text style={styles.heading}>Professional Summary</Text>\n             <Text style={styles.text}>{content.summary}</Text>\n           </View>\n           {/* Additional sections */}\n         </Page>\n       </Document>\n     );\n   }\n   ```\n\n3. Create ProseMirror editor for live editing:\n   ```typescript\n   import { EditorState } from 'prosemirror-state';\n   import { EditorView } from 'prosemirror-view';\n   import { Schema, DOMParser } from 'prosemirror-model';\n\n   const schema = new Schema({\n     nodes: {\n       doc: { content: 'block+' },\n       paragraph: { content: 'inline*', toDOM: () => ['p', 0] },\n       text: { inline: true }\n     },\n     marks: {\n       strong: { toDOM: () => ['strong', 0] },\n       em: { toDOM: () => ['em', 0] }\n     }\n   });\n   ```\n\n4. Implement resume generation flow:\n   ```typescript\n   async function generateAndPreviewResume(\n     jobId: string,\n     exaggerationLevel: 'conservative' | 'balanced' | 'strategic'\n   ) {\n     const job = await prisma.job.findUnique({ where: { id: jobId } });\n     const profile = await prisma.profile.findUnique({ where: { userId } });\n     const config = await prisma.config.findUnique({ where: { userId } });\n\n     const resumeContent = await generateTailoredResume(\n       job.description,\n       profile,\n       exaggerationLevel,\n       config.llmConfig\n     );\n\n     return resumeContent;\n   }\n   ```\n\n5. Create file naming template engine:\n   ```typescript\n   function generateFileName(template: string, job: Job): string {\n     const date = new Date().toISOString().split('T')[0];\n     return template\n       .replace('YYYY-MM-DD', date)\n       .replace('{company}', job.company)\n       .replace('{role}', job.title.replace(/[^a-zA-Z0-9]/g, '-'));\n   }\n   ```\n\n6. Create /resume route and page layout:\n   ```typescript\n   // src/app/resume/page.tsx\n   export default function ResumePage() {\n     return (\n       <div className=\"flex h-screen\">\n         <div className=\"w-1/2\"><ResumeEditor /></div>\n         <div className=\"w-1/2\"><ResumePreview /></div>\n       </div>\n     );\n   }\n   ```\n\n7. Wire LLM enhancement and PDF download actions.\n8. Implement save to Application record.",
        "testStrategy": "1. Test resume generation with sample job + profile\n2. Verify LLM produces valid markdown output\n3. Test ProseMirror editor allows editing\n4. Validate PDF export is ATS-friendly (no complex formatting)\n5. Test file naming template with various patterns\n6. Verify PDF downloads with correct filename\n7. Test all exaggeration levels produce different tones\n8. Validate resume saves to Application.resumePath\n9. Test batch generation for multiple jobs\n10. Verify PDF renders correctly on mobile\n11. Test with long content (pagination works)\n12. Verify /resume route is accessible and renders components correctly\n13. Test full flow: Enter /resume -> Generate with LLM -> Edit -> Download",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement PDF Generation with @react-pdf/renderer",
            "description": "Set up PDF generation system using @react-pdf/renderer library for ATS-friendly resume output",
            "dependencies": [],
            "details": "Install @react-pdf/renderer dependencies, create ResumePDF component with proper styling, implement Document/Page structure with ATS-compliant formatting, integrate PDFDownloadLink functionality, and verify text extraction works correctly\n<info added on 2025-12-04T00:15:38.805Z>\nPlan: Create ResumePDF component with basic layout and ATS-friendly styles. Write unit test to verify rendering.\n</info added on 2025-12-04T00:15:38.805Z>",
            "status": "done",
            "testStrategy": "Validate PDF output with ATS simulator tools, test text extraction, verify no complex formatting elements",
            "parentId": "undefined",
            "updatedAt": "2025-12-04T01:20:24.205Z"
          },
          {
            "id": 2,
            "title": "Integrate ProseMirror Editor with React",
            "description": "Create live resume editing interface using ProseMirror editor integrated with React",
            "dependencies": [],
            "details": "Set up prosemirror-state/view/model dependencies, implement react-prosemirror library for proper React integration, configure schema with resume-specific nodes/marks, create live preview component that syncs with PDF output\n<info added on 2025-12-04T01:20:41.885Z>\nPlan: Install prosemirror packages. Create ResumeEditor component with basic schema. Write test for editor initialization and content sync.\n</info added on 2025-12-04T01:20:41.885Z>",
            "status": "done",
            "testStrategy": "Test editor functionality including text formatting, verify content syncs with PDF preview, check for React reconciliation issues",
            "parentId": "undefined",
            "updatedAt": "2025-12-04T01:21:58.747Z"
          },
          {
            "id": 3,
            "title": "Implement ATS-Friendly Formatting Rules",
            "description": "Apply specific formatting constraints to ensure resumes pass Applicant Tracking Systems",
            "dependencies": [
              1
            ],
            "details": "Configure PDF styles with simple fonts (Helvetica/Arial), implement section organization without tables, ensure proper spacing and margins, validate text is selectable/not images, add semantic structure for ATS parsing\n<info added on 2025-12-04T01:22:18.399Z>\nPlan: Validate ResumePDF styles meet ATS requirements - simple fonts, no tables, proper text hierarchy. Add test to verify PDF structure.\n</info added on 2025-12-04T01:22:18.399Z>",
            "status": "done",
            "testStrategy": "Test with multiple ATS platforms, verify text extraction works, check for formatting warnings using ATS validation tools",
            "parentId": "undefined",
            "updatedAt": "2025-12-04T01:23:34.880Z"
          },
          {
            "id": 4,
            "title": "Develop Resume Generation Workflow",
            "description": "Connect ProseMirror editor with LLM service for tailored resume generation",
            "dependencies": [
              2
            ],
            "details": "Implement generateAndPreviewResume function, integrate with LLM service API, handle job description/profile data, create exaggeration level configuration, establish content flow from generation to editor and PDF preview\n<info added on 2025-12-04T01:24:03.256Z>\nPlan: Create generateAndPreviewResume server action that integrates with LLM service. Accept job description and generate tailored resume content. Write test for generation workflow.\n</info added on 2025-12-04T01:24:03.256Z>",
            "status": "done",
            "testStrategy": "Test with sample job descriptions, verify LLM output formatting, check content preservation through editor/PDF pipeline",
            "parentId": "undefined",
            "updatedAt": "2025-12-04T01:25:49.799Z"
          },
          {
            "id": 5,
            "title": "Build File Naming Template Engine",
            "description": "Create configurable system for generating resume filenames based on templates",
            "dependencies": [],
            "details": "Implement generateFileName function with variable replacement (date, company, role), add validation for template syntax, create UI for template configuration, integrate with PDF export functionality to apply naming rules\n<info added on 2025-12-04T01:26:13.160Z>\nPlan: Create generateFileName utility function with template variable replacement. Add test for file naming with various patterns.\n</info added on 2025-12-04T01:26:13.160Z>",
            "status": "done",
            "testStrategy": "Test various template patterns, verify special character handling, check date formatting, validate integration with PDF download functionality",
            "parentId": "undefined",
            "updatedAt": "2025-12-04T01:27:29.602Z"
          },
          {
            "id": 6,
            "title": "Implement /resume Route and Page Layout",
            "description": "Create the main resume page route and layout structure to host the editor and preview components",
            "dependencies": [
              1,
              2
            ],
            "details": "Create `src/app/resume/page.tsx`, implement a split-pane layout (or responsive equivalent) to display `ResumeEditor` and `ResumePreview` side-by-side, ensure the route is accessible via main navigation, and set up shared state context for data synchronization.",
            "status": "pending",
            "testStrategy": "Verify /resume route loads without errors, check responsive layout on different screen sizes, ensure both editor and preview components are mounted",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "Wire Editor, Preview, and LLM Integration",
            "description": "Connect the UI components to the backend services for a complete user flow",
            "dependencies": [
              4,
              6
            ],
            "details": "Integrate the `generateAndPreviewResume` function with the UI 'Enhance' button, ensure LLM output populates the ProseMirror editor, wire the editor's state changes to update the PDF preview in real-time, and implement the 'Download PDF' button using the file naming engine.",
            "status": "pending",
            "testStrategy": "Test the full flow: Click Enhance -> Wait for LLM -> Verify Editor Content -> Edit Text -> Verify PDF Preview Updates -> Click Download -> Verify File",
            "parentId": "undefined"
          },
          {
            "id": 8,
            "title": "Implement Resume Persistence and Application Association",
            "description": "Save the generated resume and associate it with the specific job application record",
            "dependencies": [
              7
            ],
            "details": "Implement the save functionality to store the final resume content (JSON/PDF path) to the database, update the `Application` record with the reference to the generated resume, and ensure the user can retrieve saved resumes later.",
            "status": "pending",
            "testStrategy": "Generate a resume, click save, query the database to verify the Application record is updated with the correct resume path/content",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2025-12-09T02:11:09.239Z"
      },
      {
        "id": "21",
        "title": "Develop Settings Management UI and Configuration Hot Reload",
        "description": "Create the comprehensive settings interface with tabbed layout (Search, LLM, Automation, Advanced), implement live validation, LLM connection testing, JSON Schema validation, version control for configs, and hot reload functionality without server restart.",
        "status": "done",
        "dependencies": [
          "14"
        ],
        "priority": "medium",
        "details": "1. Create tabbed settings interface:\n   ```typescript\n   // src/components/settings/SettingsPage.tsx\n   import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';\n\n   export function SettingsPage() {\n     return (\n       <Tabs defaultValue=\"search\">\n         <TabsList>\n           <TabsTrigger value=\"search\">Search Parameters</TabsTrigger>\n           <TabsTrigger value=\"llm\">LLM Configuration</TabsTrigger>\n           <TabsTrigger value=\"automation\">Automation</TabsTrigger>\n           <TabsTrigger value=\"advanced\">Advanced</TabsTrigger>\n         </TabsList>\n\n         <TabsContent value=\"search\">\n           <SearchSettings />\n         </TabsContent>\n         <TabsContent value=\"llm\">\n           <LLMSettings />\n         </TabsContent>\n         <TabsContent value=\"automation\">\n           <AutomationSettings />\n         </TabsContent>\n         <TabsContent value=\"advanced\">\n           <AdvancedSettings />\n         </TabsContent>\n       </Tabs>\n     );\n   }\n   ```\n\n2. Implement LLM connection test:\n   ```typescript\n   async function testLLMConnection(config: LLMConfig) {\n     try {\n       const llm = getLLMClient(config);\n       const response = await llm.invoke([{\n         role: 'user',\n         content: 'Respond with \"Connection successful\" if you receive this.'\n       }]);\n       return { success: true, message: response.content };\n     } catch (error) {\n       return { success: false, message: error.message };\n     }\n   }\n   ```\n\n3. Create JSON Schema validation:\n   ```typescript\n   import Ajv from 'ajv';\n\n   const configSchema = {\n     type: 'object',\n     properties: {\n       version: { type: 'string' },\n       user_id: { type: 'string' },\n       search_parameters: {\n         type: 'object',\n         properties: {\n           cities: {\n             type: 'array',\n             items: {\n               type: 'object',\n               properties: {\n                 name: { type: 'string' },\n                 radius_miles: { type: 'number', minimum: 5, maximum: 100 },\n                 weight: { type: 'number', minimum: 0, maximum: 100 }\n               },\n               required: ['name', 'radius_miles', 'weight']\n             }\n           }\n         }\n       }\n     },\n     required: ['version', 'search_parameters']\n   };\n\n   const ajv = new Ajv();\n   const validate = ajv.compile(configSchema);\n   ```\n\n4. Implement version control:\n   ```typescript\n   async function saveConfigVersion(userId: string, config: Config) {\n     const currentConfig = await prisma.config.findUnique({ where: { userId } });\n     \n     // Store previous version\n     await prisma.configHistory.create({\n       data: {\n         userId,\n         version: currentConfig.version,\n         config: currentConfig,\n         createdAt: new Date()\n       }\n     });\n\n     // Update with new version\n     await prisma.config.update({\n       where: { userId },\n       data: {\n         ...config,\n         version: incrementVersion(currentConfig.version),\n         updatedAt: new Date()\n       }\n     });\n   }\n   ```\n\n5. Create hot reload mechanism using React Context:\n   ```typescript\n   export const ConfigContext = createContext<Config | null>(null);\n\n   export function ConfigProvider({ children }) {\n     const [config, setConfig] = useState<Config | null>(null);\n\n     useEffect(() => {\n       // Poll for config changes every 5 seconds\n       const interval = setInterval(async () => {\n         const latestConfig = await fetchConfig();\n         if (latestConfig.updatedAt > config?.updatedAt) {\n           setConfig(latestConfig);\n         }\n       }, 5000);\n       return () => clearInterval(interval);\n     }, [config]);\n\n     return (\n       <ConfigContext.Provider value={config}>\n         {children}\n       </ConfigContext.Provider>\n     );\n   }\n   ```\n\n6. Add reset to defaults functionality\n7. Create config export/import UI\n8. Implement live validation with error messages",
        "testStrategy": "1. Test all tabs render correctly\n2. Verify live validation shows errors immediately\n3. Test LLM connection test button for each provider\n4. Validate JSON Schema rejects invalid configs\n5. Test version control saves previous configs\n6. Verify rollback to previous version works\n7. Test hot reload updates UI without refresh\n8. Validate reset to defaults restores original config\n9. Test export/import round-trip\n10. Verify changes persist to database and config.json",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Tabbed Settings Interface with Dynamic Content",
            "description": "Create responsive tabbed interface with four sections (Search, LLM, Automation, Advanced) that dynamically renders content based on active tab selection",
            "dependencies": [],
            "details": "Build using React Tabs component with proper accessibility attributes (aria-selected, aria-controls). Implement keyboard navigation support with arrow keys. Create separate components for each tab section. Integrate LLM connection test button in LLM tab. Add visual indicators for validation status on each form field.\n<info added on 2025-12-04T02:02:05.101Z>\nPlan: Create SettingsPage component with tabbed interface using shadcn/ui Tabs. Implement Search, LLM, Automation, and Advanced tabs. Write test to verify tab navigation.\n</info added on 2025-12-04T02:02:05.101Z>\n<info added on 2025-12-04T15:26:58.659Z>\nPlan: Implement functional SearchSettings component with form fields for cities, keywords, salary, and recency. Use React Hook Form for validation. Write tests for form submission and validation.\n</info added on 2025-12-04T15:26:58.659Z>",
            "status": "done",
            "testStrategy": "Verify all tabs render correctly, test keyboard navigation between tabs, confirm content changes when tab is selected, validate accessibility attributes are properly set",
            "parentId": "undefined",
            "updatedAt": "2025-12-04T15:40:47.087Z"
          },
          {
            "id": 2,
            "title": "Build JSON Schema Validation System with Live Feedback",
            "description": "Implement comprehensive validation system using Ajv to validate configuration against defined schema with real-time error feedback",
            "dependencies": [],
            "details": "Create validation service that compiles schema and validates config objects. Implement field-specific error messages for nested structures. Integrate with form components to show live validation status. Handle complex validation rules for search parameters and LLM configurations. Add visual indicators for invalid fields with descriptive error messages.",
            "status": "done",
            "testStrategy": "Test validation with valid and invalid configurations, verify error messages match schema constraints, confirm nested object validation works correctly, test edge cases like minimum/maximum values",
            "parentId": "undefined",
            "updatedAt": "2025-12-04T15:40:47.094Z"
          },
          {
            "id": 3,
            "title": "Implement Configuration Version Control with History Tracking",
            "description": "Create system to track configuration changes, store historical versions, and enable rollback functionality with proper version management",
            "dependencies": [],
            "details": "Build service to save config versions to database with timestamps. Implement history tracking that stores previous versions before updates. Create UI for viewing version history and selecting previous versions to restore. Add confirmation dialogs for version restoration. Ensure atomic updates to prevent data corruption during concurrent edits.",
            "status": "done",
            "testStrategy": "Test version saving after config changes, verify history is correctly stored, confirm rollback functionality works as expected, test concurrent edit handling",
            "parentId": "undefined",
            "updatedAt": "2025-12-04T15:40:47.100Z"
          },
          {
            "id": 4,
            "title": "Design Hot Reload Mechanism for Configuration Changes",
            "description": "Implement system to detect and apply configuration changes without requiring page refresh or server restart with efficient state management",
            "dependencies": [
              3
            ],
            "details": "Create ConfigContext provider that polls for changes at regular intervals. Implement comparison logic to detect updates based on timestamp. Add event listeners for immediate updates when config is saved. Ensure state updates trigger re-renders of dependent components. Add loading states during configuration updates and handle potential race conditions.",
            "status": "done",
            "testStrategy": "Test hot reload by modifying config in another tab/window, verify UI updates automatically, confirm dependent components re-render correctly, test polling interval configuration",
            "parentId": "undefined",
            "updatedAt": "2025-12-04T15:40:47.110Z"
          },
          {
            "id": 5,
            "title": "Develop Configuration Export and Import Features",
            "description": "Create UI and functionality to export current configuration as JSON file and import configurations from JSON files with validation",
            "dependencies": [
              2,
              3
            ],
            "details": "Implement export button that generates downloadable JSON file of current config. Create import UI with file picker and validation. Add preview of imported config before applying. Implement security checks to prevent malicious config imports. Add success/error notifications for import/export operations and integrate with version control system.",
            "status": "done",
            "testStrategy": "Test export generates valid JSON file, verify imported config matches exported file, confirm validation runs on imported config, test error handling for invalid JSON files",
            "parentId": "undefined",
            "updatedAt": "2025-12-04T15:40:47.119Z"
          }
        ],
        "updatedAt": "2025-12-04T16:03:26.156Z"
      },
      {
        "id": "22",
        "title": "Implement Responsive UI with Tailwind CSS and shadcn/ui Components",
        "description": "Build the complete mobile-first responsive design system using Tailwind CSS and shadcn/ui, implement dark/light theme toggle, create mobile optimizations (touch targets, swipe gestures, bottom navigation), and ensure performance targets (FCP < 1.5s, TTI < 3s).",
        "status": "done",
        "dependencies": [
          "11"
        ],
        "priority": "medium",
        "details": "1. Install shadcn/ui and configure:\n   ```bash\n   npx shadcn-ui@latest init\n   npx shadcn-ui@latest add button card input label select tabs dialog\n   ```\n\n2. Configure Tailwind with custom theme:\n   ```typescript\n   // tailwind.config.ts\n   export default {\n     darkMode: ['class'],\n     content: ['./src/**/*.{ts,tsx}'],\n     theme: {\n       extend: {\n         colors: {\n           border: 'hsl(var(--border))',\n           background: 'hsl(var(--background))',\n           foreground: 'hsl(var(--foreground))',\n           primary: {\n             DEFAULT: 'hsl(var(--primary))',\n             foreground: 'hsl(var(--primary-foreground))'\n           }\n         },\n         spacing: {\n           // 4px grid system\n         }\n       }\n     }\n   };\n   ```\n\n3. Create theme provider:\n   ```typescript\n   // src/components/theme-provider.tsx\n   import { createContext, useContext, useEffect, useState } from 'react';\n\n   type Theme = 'dark' | 'light' | 'system';\n\n   export function ThemeProvider({ children }) {\n     const [theme, setTheme] = useState<Theme>('dark');\n\n     useEffect(() => {\n       const root = window.document.documentElement;\n       root.classList.remove('light', 'dark');\n       root.classList.add(theme === 'system' ? getSystemTheme() : theme);\n     }, [theme]);\n\n     return (\n       <ThemeContext.Provider value={{ theme, setTheme }}>\n         {children}\n       </ThemeContext.Provider>\n     );\n   }\n   ```\n\n4. Implement responsive breakpoints:\n   ```css\n   /* Mobile: < 640px (default) */\n   .container { padding: 1rem; }\n\n   /* Tablet: 640px - 1024px */\n   @media (min-width: 640px) {\n     .container { padding: 2rem; }\n   }\n\n   /* Desktop: > 1024px */\n   @media (min-width: 1024px) {\n     .container { padding: 3rem; }\n   }\n   ```\n\n5. Create mobile navigation:\n   ```typescript\n   function MobileNav() {\n     return (\n       <nav className=\"fixed bottom-0 left-0 right-0 bg-background border-t md:hidden\">\n         <div className=\"flex justify-around p-2\">\n           <NavButton icon={<Home />} label=\"Home\" />\n           <NavButton icon={<Map />} label=\"Map\" />\n           <NavButton icon={<Briefcase />} label=\"Pipeline\" />\n           <NavButton icon={<Settings />} label=\"Settings\" />\n         </div>\n       </nav>\n     );\n   }\n   ```\n\n6. Implement swipe gestures:\n   ```typescript\n   import { useSwipeable } from 'react-swipeable';\n\n   const handlers = useSwipeable({\n     onSwipedLeft: () => markAsNotInterested(),\n     onSwipedRight: () => markAsInterested(),\n     trackMouse: true\n   });\n   ```\n\n7. Add Framer Motion animations:\n   ```typescript\n   import { motion } from 'framer-motion';\n\n   <motion.div\n     initial={{ opacity: 0, y: 20 }}\n     animate={{ opacity: 1, y: 0 }}\n     transition={{ duration: 0.3 }}\n   >\n     {content}\n   </motion.div>\n   ```\n\n8. Optimize performance:\n   - Lazy load images with next/image\n   - Code split routes with dynamic imports\n   - Implement virtual scrolling for long lists\n   - Add service worker for offline support",
        "testStrategy": "1. Test responsive design on mobile (< 640px)\n2. Verify tablet layout (640px - 1024px)\n3. Test desktop layout (> 1024px)\n4. Validate dark/light theme toggle works\n5. Test touch targets are minimum 44Ã—44px\n6. Verify swipe gestures work on mobile\n7. Test bottom navigation on mobile\n8. Measure FCP < 1.5s with Lighthouse\n9. Measure TTI < 3s on 4G throttling\n10. Verify Lighthouse score > 90\n11. Test on Google Pixel and iPhone 14\n12. Validate animations are smooth (60fps)",
        "subtasks": [
          {
            "id": 1,
            "title": "Configure shadcn/ui Component Library",
            "description": "Set up shadcn/ui component library with required components and proper configuration",
            "dependencies": [],
            "details": "Execute 'npx shadcn-ui@latest init' to initialize the library. Configure components.json with proper settings including style, rsc, tsx, tailwind configuration, and icon library. Add required components using 'npx shadcn-ui@latest add button card input label select tabs dialog'. Verify component installation by importing and rendering a test button component.\n<info added on 2025-12-04T16:18:15.780Z>\nVerify shadcn/ui configuration and check tailwind.config.ts theme setup. Add any missing UI components. Write tests to verify the component library is accessible.\n</info added on 2025-12-04T16:18:15.780Z>",
            "status": "done",
            "testStrategy": "Verify components are properly installed by checking component files in project structure and rendering a test button component",
            "parentId": "undefined",
            "updatedAt": "2025-12-04T16:22:15.242Z"
          },
          {
            "id": 2,
            "title": "Implement Mobile-First Responsive Design System",
            "description": "Create responsive layout with mobile-first approach using Tailwind CSS breakpoints",
            "dependencies": [
              1
            ],
            "details": "Configure Tailwind CSS breakpoints for mobile (<640px), tablet (640px-1024px), and desktop (>1024px). Implement mobile-specific optimizations including bottom navigation bar, touch targets of minimum 44x44px, and swipe gesture handling using react-swipeable. Create responsive container classes with appropriate padding for each breakpoint. Test layouts on various device sizes.\n<info added on 2025-12-04T16:23:33.250Z>\nPlan: Create MobileNav component with bottom navigation. Implement responsive breakpoints. Add touch-friendly tap targets (min 44px). Write tests for mobile navigation and responsive behavior.\n</info added on 2025-12-04T16:23:33.250Z>",
            "status": "done",
            "testStrategy": "Test responsive design on mobile (<640px), tablet (640px-1024px), and desktop (>1024px) viewports. Verify touch targets meet minimum size requirements and swipe gestures function correctly on mobile devices.",
            "parentId": "undefined",
            "updatedAt": "2025-12-04T16:25:10.687Z"
          },
          {
            "id": 3,
            "title": "Implement Dark/Light Theme Toggle System",
            "description": "Create theme provider with dark/light mode toggle functionality and consistent theming across components",
            "dependencies": [
              1
            ],
            "details": "Configure Tailwind CSS with darkMode: ['class'] setting. Implement theme provider component that manages theme state (light, dark, system) and applies appropriate CSS classes. Set up CSS variables for border, background, foreground, and primary colors. Create theme toggle button component that allows users to switch between themes. Ensure all shadcn/ui components properly respond to theme changes.",
            "status": "done",
            "testStrategy": "Verify theme toggle button works correctly. Test all components render properly in both light and dark modes. Confirm theme preference persists across page reloads. Validate theme system works with system preference detection.",
            "parentId": "undefined",
            "updatedAt": "2025-12-04T16:37:22.530Z"
          },
          {
            "id": 4,
            "title": "Optimize UI Performance to Meet Targets",
            "description": "Implement performance optimizations to achieve FCP < 1.5s and TTI < 3s metrics",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Implement lazy loading for images using next/image component. Apply code splitting for routes using dynamic imports. Implement virtual scrolling for long lists using libraries like react-virtualized. Add service worker for offline support and caching. Optimize component rendering with React.memo and useCallback. Measure performance metrics using Lighthouse and implement necessary improvements to meet targets.",
            "status": "done",
            "testStrategy": "Measure FCP and TTI using Lighthouse and Web Vitals. Verify lazy loading works for images. Confirm code splitting reduces initial bundle size. Test virtual scrolling performance with large datasets. Validate service worker caching strategy.",
            "parentId": "undefined",
            "updatedAt": "2025-12-04T16:25:10.693Z"
          }
        ],
        "updatedAt": "2025-12-04T19:07:23.673Z"
      },
      {
        "id": "23",
        "title": "Audit Process Reform and Runtime Verification Protocols",
        "description": "Update project documentation to mandate runtime verification for all future task audits, ensuring the application builds, starts, and serves valid responses before approval.",
        "details": "1. Modify `AUDITOR.md` to explicitly state: 'No task shall be marked as completed based solely on static code analysis.'\n2. Define the 'Runtime Verification Standard' in the documentation:\n   - Clean dependency install (`npm ci`).\n   - Successful production build (`npm run build`).\n   - Dev server startup (`npm run dev`) without immediate crash.\n   - Manual or automated check that core routes (/, /pipeline, /settings, /map) return HTTP 200.\n3. Create a convenience script `scripts/pre-audit-check.sh` that runs linting, type checking, and a build test.\n4. Update `CONTRIBUTING.md` to reflect that broken builds or runtime errors will result in immediate task rejection.",
        "testStrategy": "1. Review `AUDITOR.md` for the new mandatory runtime checks.\n2. Run the `scripts/pre-audit-check.sh` on the current main branch to ensure the current state passes.\n3. Manually verify `npm run dev` starts successfully.\n4. Navigate to the Dashboard, Kanban, and Settings pages to verify they load (HTTP 200).\n5. Introduce a deliberate syntax error and verify the audit check script fails.",
        "status": "pending",
        "dependencies": [
          "22"
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": "24",
        "title": "Implement Core Route Pages and Navigation Structure",
        "description": "Assemble the primary application pages (/jobs, /settings, /dashboard) by integrating existing feature components, establishing the routing architecture, and ensuring all navigation links return valid HTTP 200 responses.",
        "details": "1. **Route Configuration**: Set up the routing architecture (e.g., Next.js App Router) to define endpoints for `/jobs`, `/settings`, and `/dashboard`.\n2. **Settings Page Integration**: Create `src/app/settings/page.tsx` and import the `SettingsPage` component (from Task 21). Wrap it in the main application layout to ensure consistent navigation.\n3. **Jobs Page Implementation**: Develop the `/jobs` route to display a paginated list or grid of job opportunities fetched via Prisma. Reuse the `JobCard` or similar UI components defined in Task 22.\n4. **Dashboard Aggregation**: Update the root dashboard to display summary widgets:\n   - Pipeline status summary (counts of jobs in 'Applied', 'Interviewing' from Task 19).\n   - Recent activity feed.\n   - Quick actions menu.\n5. **Navigation Wiring**: Update the global `Sidebar` or `Navbar` component (from Task 22) to ensure all `Link` components point to the correct routes.\n6. **Error Handling**: Implement a global `not-found.tsx` and `error.tsx` to handle invalid routes gracefully.",
        "testStrategy": "1. **Route Verification**: Manually navigate to `/jobs`, `/settings`, and `/dashboard` to confirm HTTP 200 status and correct rendering.\n2. **Settings Rendering**: Verify that the Settings tabs (Search, LLM, Automation) appear and function within the `/settings` route.\n3. **Navigation Integrity**: Click every link in the main navigation menu to ensure no broken links or client-side routing errors occur.\n4. **Data Display**: Confirm the Jobs page renders a list of jobs (or an empty state) and the Dashboard correctly reflects counts from the Kanban pipeline.\n5. **Responsiveness**: Check that these new pages adhere to the mobile-first design established in Task 22.",
        "status": "pending",
        "dependencies": [
          "19",
          "21",
          "22"
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": "25",
        "title": "Implement Database-Free Mock Mode and Data Fallbacks",
        "description": "Develop a mock data layer that intercepts database calls when the application is in 'Mock Mode', enabling full UI navigation, testing, and building without active PostgreSQL or Redis connections.",
        "details": "1. **Environment Configuration**: Add `NEXT_PUBLIC_MOCK_MODE` to `.env` and create a utility to check this status.\n2. **Mock Data Generators**: Install `@faker-js/faker` and create factory functions for all Prisma models defined in Task 12 (User, Profile, Job, Application, Config). Ensure data adheres to the schema types.\n3. **Repository Pattern / Abstraction**: Refactor direct `prisma` calls in API routes and Server Actions into a data access layer or service wrapper. \n   ```typescript\n   // src/lib/db-access.ts\n   import { prisma } from '@/lib/prisma';\n   import { mockDb } from '@/lib/mock-db';\n   \n   export const getJobs = async () => {\n     if (process.env.NEXT_PUBLIC_MOCK_MODE === 'true') return mockDb.job.findMany();\n     return prisma.job.findMany();\n   };\n   ```\n4. **Mock Implementation**: Implement an in-memory store (singleton) for the mock DB to persist state during the session (e.g., creating a job in mock mode should show up in the list until refresh).\n5. **Script Update**: Add `npm run dev:mock` to `package.json` that sets the environment variable before starting Next.js.",
        "testStrategy": "1. **Environment Isolation**: Stop all local database containers (PostgreSQL/Redis).\n2. **Startup Verification**: Run `npm run dev:mock` and verify the application starts without connection errors.\n3. **Navigation Check**: Navigate to `/settings` (Task 21) and verify that configuration data loads from the mock source.\n4. **Interaction Test**: Perform a 'write' operation (e.g., update a setting) in mock mode and verify the UI reflects the change immediately (in-memory persistence).\n5. **Build Verification**: Run `npm run build` with mock mode enabled to ensure CI pipelines can pass without a live database.",
        "status": "pending",
        "dependencies": [
          "12",
          "21"
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": "26",
        "title": "Implement End-to-End Testing Suite with Playwright",
        "description": "Set up and configure Playwright to run browser-based E2E tests verifying application startup, core route navigation, authentication flows, and UI interactivity like theme toggling.",
        "details": "1. **Installation & Configuration**: Initialize Playwright (`npm init playwright@latest`). Configure `playwright.config.ts` to support multiple browsers (Chromium, Firefox, Webkit) and set the `webServer` command to run the Next.js app in Mock Mode (leveraging Task 25).\n2. **Test Environment Setup**: Ensure tests run against `NEXT_PUBLIC_MOCK_MODE=true` to avoid database dependencies during CI execution. Create a `global-setup.ts` if necessary to seed mock state.\n3. **Core Specs Implementation**:\n   - `specs/navigation.spec.ts`: Verify navigation to `/dashboard`, `/jobs`, and `/settings` (Task 24) results in HTTP 200 and correct page headers.\n   - `specs/theme.spec.ts`: Locate the theme toggle button (Task 22), click it, and assert that the `<html>` class attribute switches between 'light' and 'dark'.\n   - `specs/auth.spec.ts`: Specific test for the login form submission and redirection logic.\n4. **CI Integration**: Add scripts to `package.json` (`test:e2e`, `test:e2e:ui`) and ensure HTML reports are generated.",
        "testStrategy": "1. **Local Execution**: Run `npm run test:e2e` and confirm all tests pass in headless mode.\n2. **Visual Verification**: Run `npx playwright test --ui` to visually inspect the browser interactions during test execution.\n3. **Theme Logic**: Specifically verify that the theme toggle test fails if the class name does not update on the `html` element.\n4. **Mock Integration**: Confirm tests pass without a running PostgreSQL container, validating the integration with Task 25.",
        "status": "pending",
        "dependencies": [
          "22",
          "24",
          "25"
        ],
        "priority": "high",
        "subtasks": []
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2025-12-12T23:34:31.037Z",
      "taskCount": 16,
      "completedCount": 10,
      "tags": [
        "tdd"
      ]
    }
  }
}